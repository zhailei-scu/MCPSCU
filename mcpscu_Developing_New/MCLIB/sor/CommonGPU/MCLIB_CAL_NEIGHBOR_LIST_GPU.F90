!  Free-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  9/24/2017 11:29:00 PM
module MCLIB_CAL_NEIGHBOR_LIST_GPU

  use cudafor
  use MCLIB_TYPEDEF_SIMULATIONBOXARRAY_GPU

  implicit none

  !------Vars--------------
  integer,private,parameter::p_MXNEAREST = 2048                                         ! the pre-allocated number for nearest around neighborhood(which is used for
                                                                                        ! the default pre-allocated number in device,actual number for nearest around
                                                                                        ! neighborhood is defined by the m_NeighborNum which givend by
                                                                                        ! the user control file)

  real(kind=KINDDF),private,device,dimension(:,:),allocatable::dm_CumulateSep
  real(kind=KINDDF),private,dimension(:,:),allocatable::m_CumulateSep
  integer,private,device,dimension(:,:),allocatable::dm_CumulateSepCount
  integer,private,dimension(:,:),allocatable::m_CumulateSepCount

  contains
  !**********************************************************************************
  subroutine Cal_Neighbor_List_GPU(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,Record,IfDirectly,RMAX,MaxDiffuse)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    CLASS(SimulationRecord)::Record
    logical,optional::IfDirectly
    real(kind=KINDDF),optional::RMAX
    real(kind=KINDDF),optional::MaxDiffuse
    !---Local Vars---
    logical::SureToUpdateNL
    integer::NAct
    !---Body---

    if(Host_SimuCtrlParam%FreeDiffusion .eq. .true.) then
        return
    end if

    SureToUpdateNL = .false.

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + &
           Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    if(present(IfDirectly)) then
        if(IfDirectly .eq. .true.) then
            SureToUpdateNL = .true.
        end if
    end if

    if(SureToUpdateNL .eq. .false.) then
        select case(Host_SimuCtrlParam%NEIGHBORUPDATESTRATEGY)
            case(mp_NEIGHBORUPDATEBYNCREMIND)
                if(dble(NAct)/dble(Record%GetLastUpdateNLNC0()) .LE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                        SureToUpdateNL = .true.
                end if
            case(mp_NEIGHBORUPDATEBYSTEP)
                if((Record%GetSimuSteps() - Record%GetLastUpdateNLTime()) .GE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                    SureToUpdateNL = .true.
                end if
        end select
    end if

    if(SureToUpdateNL .eq. .true.) then

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR .or.   &
           Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR_LastPassage_Integer) then

           select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_SortX)
                    if(.not. present(MaxDiffuse)) then
                        write(*,*) "MCPSCUERROR: Must special the max diffusor if the SortX neighbor-list is used."
                        pause
                        stop
                    end if
                    call Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
           end select

        else
            select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    if(.not. present(RMAX)) then
                        write(*,*) "MCPSCUERROR: Must special the max radius if the cut-off neighbor-list is used."
                        pause
                        stop
                    end if
                    call Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
            end select
        end if

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NearestSep) then
            call CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        end if

        call Record%SetLastUpdateNLNC0(NAct)
        call Record%SetLastUpdateNLTime((dble(Record%GetSimuSteps())))

        call Dev_Boxes%dm_ClusterInfo_GPU%IncreaseOneNLUpdateCount_Dev()
    end if

    return
  end subroutine Cal_Neighbor_List_GPU

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam        , the user defined number of nearest neighborhood
    !             Dev_Boxes                , boxes information in device
    !             RCUT                     , the cu-off radius of calculating neighbores
    !
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::RMAX
    !---Local Vars---
    integer::MultiBox
    type(dim3) :: blocks
    type(dim3) :: threads
    integer::NB, NBX, NBY, BX, BY, err
    real(kind=KINDDF)::RCUT,RCUT2
    integer::BlockNumEachBox
    integer::NNearestNeighbor
    logical, device::Dev_ExplosiveMerge
    logical::Host_ExplosiveMerge
    integer::NAct
    logical::ChangedToUsedIndex
    !---Body---

    #ifdef MC_PROFILING
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    call Time_Start(T_Cal_Neighbore_Table_GPU_Old_Start)
    #endif
    !---Body---
    ChangedToUsedIndex = .false.

    MultiBox = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if

    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    RCUT = Calc_RCUT_Old(Host_SimuCtrlParam%MultiBox,Host_SimuCtrlParam%CUTREGIONEXTEND,Host_Boxes%BOXVOLUM,NAct,RMAX)
    RCUT2 = RCUT*RCUT

    !DO I=1, NB
    !     IP = (I - 1)*p_BLOCKSIZE + 1
    !     IPM = min(IP + p_BLOCKSIZE - 1, NC)
    !     call DEV_Cal_Neighbore_Table<<<blocks,threads>>>(NC, DSIZE, Dev_Clusters,RCUT2, IP, IPM, Dev_NeighborKVOIS,dm_INDI)
    !END DO
    !--------New Version,the divide operation is included in the core fuction------

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEExpdIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     else
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEUsedIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     end if


    err = cudaThreadSynchronize()

    !call GetMaxNeighborhoods_RCUT(TNC,Dev_NeighborKVOIS)

    Host_ExplosiveMerge = Dev_ExplosiveMerge

    if(Host_ExplosiveMerge .eq. .true.) then
        write(*,*) "MCPSCUERROR: There are explosive clusters growth happened."
        pause
        stop
    end if

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Old_Start,T_Cal_Neighbore_Table_GPU_Old)
    #endif
    return
  end subroutine Cal_Neighbore_Table_GPU_Old

  !******************************************************************
  attributes(global) subroutine Kernel_NeighborList_Rcut(MAXNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,RCUT2,Dev_ExplosiveMerge,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             MAXNeighbor           , the user defined number of  neighborhoods
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index of cluster used for neighbor-list calculation in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    !             RCUT2                 , the pow2 of cut-off distance
    !             Dev_ExplosiveMerge    , the explosive statu
    implicit none
    !
    !---Dummy Vars---
    integer,value::MAXNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    real(kind=KINDDF), value::RCUT2
    logical,device::Dev_ExplosiveMerge
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IS,IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DIST2
    integer::NN
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
         Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
         Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
         Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
         Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. MAXNeighbor) then
                    if(DIST2 .LE. RCUT2) then
                      NN = NN + 1
                      KVOIS(IC) = NN
                      INDI(IC,NN) = I
                    end if
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_RCUT


  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox

    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEActIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEActIndexBox(:,1)))/p_BLOCKSIZE + 1
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    call Kernel_NeighborList_Nearest_WithActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                  &
                                                                         Dev_Boxes%dm_SEExpdIndexBox,      &
                                                                         Dev_Boxes%dm_SEActIndexBox,        &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_ActiveIndex,   &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS, &
                                                                         BlockNumEachBox)

    err = cudaThreadSynchronize()

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithActiveIndex(NNearestNeighbor,Dev_SEExpdIndexBox,Dev_SEActIndexBox, &
                                                                            Dev_Clusters,Dev_ActiveIndex,INDI,KVOIS,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters  that need to calculate the neighbor-list in each box
    !             Dev_SEActIndexBox     , start and end active clusters index for each box
    !             Dev_Clusters          , clusters array
    !             Dev_ActiveIndex       , the active clusters index in device
    !             INDI                  , the index list of the neighbores
    !             KVOIS                 , the number of neighbores of clusters

    implicit none
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer, device::Dev_SEActIndexBox(:,:)
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_ActiveIndex(:)
    integer,device::INDI(:,:)
    integer,device::KVOIS(:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    integer::mappedIndex,mapped_SharedIndex
    integer::eActId
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    mappedIndex = Dev_ActiveIndex(IC)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(mappedIndex .LE. ecid) then
        Pos_x = Dev_Clusters(mappedIndex)%m_POS(1)
        Pos_y = Dev_Clusters(mappedIndex)%m_POS(2)
        Pos_z = Dev_Clusters(mappedIndex)%m_POS(3)
        STATU = Dev_Clusters(mappedIndex)%m_Statu
        KVOIS(mappedIndex) = 0
    end if

    ICFROM = scid
    eActId = scid + Dev_SEActIndexBox(IB,2) - Dev_SEActIndexBox(IB,1)
    ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

    DO while(ICTO .GE. ICFROM)

       if((ICFROM+tid-1) .LE. ecid) then
         mapped_SharedIndex = Dev_ActiveIndex(ICFROM+tid-1)

         if(mapped_SharedIndex .LE. ecid) then
           Shared_Statu(tid) = Dev_Clusters(mapped_SharedIndex)%m_Statu
           Shared_PosX(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(1)
           Shared_PosY(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(2)
           Shared_PosZ(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(3)
         end if
       end if

       call syncthreads()

       IF(mappedIndex .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then  ! it is true for IC, not mappedIndex

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(mappedIndex) = NN
                    INDI(mappedIndex,NN) = Dev_ActiveIndex(I)
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = Dev_ActiveIndex(I)
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    else
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    end if


    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = I
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    else
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    end if


    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,MinTSteps)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    real(kind=KINDDF),device::MinTSteps(:)
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_DiffCoeff
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_RR
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_Time
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxTime,temp_Time
    integer::Nearest_maxTimeIndex
    real(kind=KINDDF)::MinT,reactTime
    integer::NN
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxTime=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        DiffA = Dev_Clusters(IC)%m_DiffCoeff
        RADA = Dev_Clusters(IC)%m_RAD
        KVOIS(IC) = 0

        MinTSteps(IC) = 1.D32
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    MinT = 1.D32

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
        Shared_DiffCoeff(tid) = Dev_Clusters(ICFROM+tid-1)%m_DiffCoeff
        Shared_RR(tid) = Dev_Clusters(ICFROM+tid-1)%m_RAD
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  RADB = Shared_RR(JC)

                  DiffB = Shared_DiffCoeff(JC)

                  DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                  reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time


                  if(reactTime .LE. MinT ) then
                    MinT = reactTime
                  end if

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_Time(NN) = reactTime

                    if(Nearest_maxTime .LT. reactTime) then

                      Nearest_maxTime = reactTime
                      Nearest_maxTimeIndex = NN
                    end if

                  else if(Nearest_maxTime .GT. reactTime) then

                    INDI(IC,Nearest_maxTimeIndex) = I
                    Nearest_Time(Nearest_maxTimeIndex) = reactTime
                    Nearest_maxTime = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_Time = Nearest_Time(K)
                      if(temp_Time .GT. Nearest_maxTime) then

                        Nearest_maxTime = temp_Time
                        Nearest_maxTimeIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    if(IC .LE. ecid) then
        MinTSteps(IC) = MinT
    end if

    return
  end subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex

  !********************************************************
  subroutine CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        ! Note: this subroutine relate one the neighbor-list in GPU, please ensure that neighbor-list had been stored in Dev_Boxes
        implicit none
        !---Dummy Vars---
        type(SimulationBoxes)::Host_Boxes
        type(SimulationCtrlParam)::Host_SimuCtrlParam
        type(SimulationBoxes_GPU)::Dev_Boxes
        !---Local Vars---
        integer::MULTIBOX
        integer::BlockNumEachBox
        integer::BlockNumEachBoxExpd,BlockNumEachBoxVirtual
        type(dim3)::blocks
        type(dim3)::threads
        integer::NBExpd,NBVirtual
        integer::BX,BY,NB,err
        integer::NBAllocate
        integer::NCActFreeClusters
        integer::NCActFreeClustersEachBox
        integer::NCActGBClusters
        integer::NCActGBClustersEachBox
        integer::IBox
        integer::IBFROM
        integer::IBTO
        !---Body---
        ASSOCIATE(Dev_ClusterInfo_GPU=>Dev_Boxes%dm_ClusterInfo_GPU)

            MULTIBOX = Host_SimuCtrlParam%MultiBox

            if(maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)) .LT. 0) then
                return
            end if

            BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NB = BlockNumEachBox*MultiBox

            BlockNumEachBoxExpd = (maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBExpd = BlockNumEachBoxExpd*MultiBox

            BlockNumEachBoxVirtual = (maxval(Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBVirtual = BlockNumEachBoxVirtual*MultiBox

            !---Here, the array size is domain by the virtual or expd situation, for used situation,
            !   The array size maybe a little bigger than used size
            !   The main purpose to let what happen is that we do not want to allocate a suitable memory size
            !   for used situation in each step, because for implant, the used size is keeping changing and we should not adjustment below
            !   memory each step, so we use the virtual or expd size, which mean, while GetBoxesMigCoaleStat_Expd_GPU or
            !   GetBoxesMigCoaleStat_Virtual_GPU is used, we had get a bigger block of memory size that can ensure the usage
            !   for next N steps and need not to adjustment memory size.
            NBAllocate = max(NB,NBExpd,NBVirtual)

            if(.not. allocated(m_CumulateSep)) then
                allocate(m_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSep,dim=2)) then
                deallocate(m_CumulateSep)
                allocate(m_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSep)) then
                allocate(dm_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSep,dim=2)) then
                deallocate(dm_CumulateSep)
                allocate(dm_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(m_CumulateSepCount)) then
                allocate(m_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSepCount,dim=2)) then
                deallocate(m_CumulateSepCount)
                allocate(m_CumulateSepCount(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSepCount)) then
                allocate(dm_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSepCount,dim=2)) then
                deallocate(dm_CumulateSepCount)
                allocate(dm_CumulateSepCount(2,NBAllocate))
            end if

            !*** to determine the block size
            BX = p_Reduce_BLOCKSIZE
            BY = 1
            !*** to determine the dimension of blocks

            blocks  = dim3(NB, 1, 1)
            threads = dim3(BX, BY, 1)

            call CalSep_Kernel<<<blocks,threads>>>(BlockNumEachBox,                    &
                                                   Dev_ClusterInfo_GPU%dm_Clusters,    &
                                                   Dev_Boxes%dm_SEUsedIndexBox,        &
                                                   Dev_ClusterInfo_GPU%dm_KVOIS,       &
                                                   Dev_ClusterInfo_GPU%dm_INDI,        &
                                                   dm_CumulateSepCount,                &
                                                   dm_CumulateSep)

            m_CumulateSepCount = dm_CumulateSepCount

            m_CumulateSep  = dm_CumulateSep

            DO IBox = 1,MULTIBOX
                IBFROM = (IBox -1)*BlockNumEachBox + 1
                IBTO = IBox*BlockNumEachBox

                NCActFreeClustersEachBox = sum(m_CumulateSepCount(1,IBFROM:IBTO))
                if(NCActFreeClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,IBFROM:IBTO))/NCActFreeClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if

                NCActGBClustersEachBox = sum(m_CumulateSepCount(2,IBFROM:IBTO))
                if(NCActGBClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = sum(m_CumulateSep(2,IBFROM:IBTO))/NCActGBClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if
            END DO

            NCActFreeClusters = sum(m_CumulateSepCount(1,1:NB))
            if(NCActFreeClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,1:NB))/NCActFreeClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

            NCActGBClusters = sum(m_CumulateSepCount(2,1:NB))
            if(NCActGBClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = sum(m_CumulateSep(2,1:NB))/NCActGBClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

        END ASSOCIATE
        return
  end subroutine CalClustersSep_Dev

  !********************************************************
  attributes(global) subroutine CalSep_Kernel(BlockNumEachBox,Dev_Clusters,Dev_SEUsedIndexBox,Neighbor_KVOIS,Neighbor_INDI,CumulateSepCount,CumulateSep)
        implicit none
        !---Dummy Vars---
        integer,value::BlockNumEachBox
        type(Acluster),device::Dev_Clusters(:)
        integer,device::Dev_SEUsedIndexBox(:,:)
        integer,device::Neighbor_KVOIS(:)
        integer,device::Neighbor_INDI(:,:)
        integer,device::CumulateSepCount(2,*)
        real(kind=KINDDF),device::CumulateSep(2,*)
        !---Local Vars---
        integer::tid,bid,bid0,cid
        integer::IC
        integer::IBox
        integer::scid,ecid
        real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z
        real(kind=KINDSF)::Sep_X,Sep_Y,Sep_Z
        real(kind=KINDSF)::RADA,RADB,DIST,RR
        integer::N_Neighbor
        integer::I,J,JC
        real(kind=KINDDF)::MinDist
        real(kind=KINDDF),shared::Share_CumulateSep(p_Reduce_BLOCKSIZE)
        integer,shared::Share_CumulateSepCount(p_Reduce_BLOCKSIZE)
        !---Body---
        tid = (threadidx%y - 1)*blockdim%x + threadidx%x
        bid = (blockidx%y  - 1)*griddim%x  + blockidx%x
        cid = (bid -1)*p_Reduce_BLOCKSIZE + tid

        IBox = (bid - 1)/BlockNumEachBox + 1

        bid0 = (IBox - 1)*BlockNumEachBox

        scid = Dev_SEUsedIndexBox(IBox,1)

        ecid = Dev_SEUsedIndexBox(IBox,2)

        IC = scid + (cid - bid0*p_Reduce_BLOCKSIZE -1)

        !----For p_ACTIVEFREE_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEFREE_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEFREE_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if


        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(1,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(1,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        call syncthreads()

        !----For p_ACTIVEGB_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEINGB_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEINGB_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if

        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(2,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(2,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        return
  end subroutine CalSep_Kernel



!  __global__ void Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen(int BlockNumEachBox, int **IDStartEnd_Dev, double** Dev_ClustersPosXYZ, int* SortedIndexX, int* Dev_NNearestNeighbor) {
!	int tid = threadIdx.y*blockDim.x + threadIdx.x;
!	int bid = blockIdx.y*gridDim.x + blockIdx.x;
!	int cid = bid * BLOCKSIZE + tid;
!	double Pos_X;
!	double Pos_Y;
!	double Pos_Z;
!	int MappedJC;
!	double distance;
!	double minDistance;
!	double distanceX;
!	double distanceY;
!	double distanceZ;
!	int NNID;
!	int MapedIdex;
!	int IBox;
!	int scid;
!	int ecid;
!	int bid0;
!	int IC;
!	int JC;
!	int LeftRemind;
!	int RightRemind;
!	int MaxRemind;
!	bool flagLeftBreak;
!	bool flagRightBreak;
!	flagLeftBreak = false;
!	flagRightBreak = false;
!
!	IBox = bid / BlockNumEachBox;
!
!	scid = IDStartEnd_Dev[IBox][0];
!	ecid = IDStartEnd_Dev[IBox][1];
!
!	bid0 = IBox * BlockNumEachBox;
!
!	IC = scid + (cid - bid0 * BLOCKSIZE);
!
!	minDistance = 1.E32;
!
!	if (IC <= ecid) {
!
!		MapedIdex = SortedIndexX[IC];
!
!		Pos_X = Dev_ClustersPosXYZ[MapedIdex][0];
!		Pos_Y = Dev_ClustersPosXYZ[MapedIdex][1];
!		Pos_Z = Dev_ClustersPosXYZ[MapedIdex][2];
!
!		LeftRemind = IC - scid;
!		RightRemind = ecid - IC;
!
!		MaxRemind = RightRemind;
!		if (LeftRemind > MaxRemind) MaxRemind = LeftRemind;
!
!		for (int Shift = 1; Shift <= MaxRemind; Shift++) {
!
!			/*Right Hand Searching*/
!			if (Shift <= RightRemind && false == flagRightBreak) {
!				JC = IC + Shift;
!
!				MappedJC = SortedIndexX[JC];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJC;
!				}
!
!				if (distanceX > minDistance) {
!					flagRightBreak = true;
!
!					if (true == flagLeftBreak) {
!						break;
!					}
!				}
!			}
!
!			/*Left Hand Searching*/
!			if (Shift <= LeftRemind && false == flagLeftBreak) {
!				JC = IC - Shift;
!
!				MappedJC = SortedIndexX[JC];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJC;
!				}
!
!				if (distanceX > minDistance) {
!					flagLeftBreak = true;
!
!					if (true == flagRightBreak) {
!						break;
!					}
!				}
!			}
!
!		}
!
!		Dev_NNearestNeighbor[MapedIdex] = NNID;
!	}
!}

  attributes(global) subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen(Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,SortedIndexX,MinTSteps,maxDiffuse)
    implicit none
    !--Dummy Vars---
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    integer,device::SortedIndexX(:)
    real(kind=KINDDF),device::MinTSteps(:)
    real(kind=KINDDF),value::maxDiffuse
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::scid
    integer::ecid
    integer::bid0
    integer::IC
    integer::JC
    integer::MapedIdex
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::NClusters
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::minDistance
    logical::flagRightBreak,flagLeftBreak
    integer::NNID
    integer::Flag
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	scid = Dev_SEExpdIndexBox(IBox,1)
	ecid = Dev_SEExpdIndexBox(IBox,2)

	NClusters = ecid - scid + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

	MinT = 1.D32
	minDistance = 1.D32

	flagRightBreak = .false.
	flagLeftBreak = .false.

	if (IC .LE. ecid) then

		MapedIdex = SortedIndexX(IC)

        STATUIC = Dev_Clusters(MapedIdex)%m_Statu

        IF(STATUIC .EQ. p_ACTIVEFREE_STATU .or. STATUIC .EQ. p_ACTIVEINGB_STATU) THEN
          Pos_X = Dev_Clusters(MapedIdex)%m_POS(1)
          Pos_Y = Dev_Clusters(MapedIdex)%m_POS(2)
          Pos_Z = Dev_Clusters(MapedIdex)%m_POS(3)

          RADA = Dev_Clusters(MapedIdex)%m_RAD

          DiffA = Dev_Clusters(MapedIdex)%m_DiffCoeff

          DO Shift=1,NClusters-1

			!***********Right hand searching**********************
			JC = IC + Shift
			Flag = (JC .GT. ecid)
			Flag = Flag*Flag
            JC = JC - Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form
			if (.false. .eq. flagRightBreak .AND. JC .LE. ecid) then

				MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT)
                    end if

				    if (SEP_x .GT. minDistance) then
					  flagRightBreak = .true.

					  if (.true. .eq. flagLeftBreak) then
						  exit
                      end if
				    end if

                end if

            end if

            !***********Left hand searching**********************
			JC = IC - Shift
			Flag = (JC .LT. scid)
			Flag = Flag*Flag
            JC = JC + Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form
			if (.false. .eq. flagLeftBreak .AND. JC .GE. scid) then

				MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT)
                    end if

				    if (SEP_x .GT. minDistance) then
					  flagLeftBreak = .true.

					  if (.true. .eq. flagRightBreak) then
						  exit
                      end if
				    end if

                end if

            end if

          END DO

          KVOIS(MapedIdex) = 1
		  INDI(MapedIdex,1) = NNID
		  MinTSteps(MapedIdex) = MinT
        end if
	 end if

	 return
  end subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen


!  void My_NeighborListCal_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(int NClusters, int NBox, int **IDStartEnd_Host, &
!                                                                                   int **IDStartEnd_Dev, double* ToSortDev_ClustersPosX,
!                                                                                   double** Dev_ClustersPosXYZ, int* SortedIndexX, int* ReverseMap_SortedIndexX,  int* Host_NNearestNeighbor, float &timerMyMethod) {
!	dim3 threads;
!	dim3 blocks;
!	int NB;
!	cudaError err;
!	int noone;
!	int BlockNumEachBox;
!	int BlockNumEachBoxtemp;
!	int* Dev_NNearestNeighbor;
!
!	cudaMalloc((void**)&Dev_NNearestNeighbor, NClusters * sizeof(int));
!
!	SimpleSort_multipleBox(NClusters, NBox, IDStartEnd_Host, ToSortDev_ClustersPosX, SortedIndexX, ReverseMap_SortedIndexX);
!
!	cudaEvent_t StartEvent;
!	cudaEvent_t StopEvent;
!
!	BlockNumEachBox = 0;
!
!	for (int i = 0; i < NBox; i++) {
!		BlockNumEachBoxtemp = (IDStartEnd_Host[i][1] - IDStartEnd_Host[i][0]) / BLOCKSIZE + 1;
!
!		if (BlockNumEachBox < BlockNumEachBoxtemp) BlockNumEachBox = BlockNumEachBoxtemp;
!	}
!
!	NB = BlockNumEachBox * NBox;
!
!	blocks = dim3(NB, 1, 1);
!	threads = dim3(BLOCKSIZE, 1, 1);
!
!	cudaDeviceSynchronize();
!
!	cudaEventCreate(&StartEvent);
!	cudaEventCreate(&StopEvent);
!
!	cudaEventRecord(StartEvent, 0);
!
!	Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<< < blocks, threads >> > (BlockNumEachBox, IDStartEnd_Dev, Dev_ClustersPosXYZ, SortedIndexX, Dev_NNearestNeighbor);
!
!	cudaDeviceSynchronize();
!
!	cudaEventRecord(StopEvent, 0);
!
!	cudaEventSynchronize(StopEvent);
!
!	cudaEventElapsedTime(&timerMyMethod, StartEvent, StopEvent);
!
!	cudaMemcpy(Host_NNearestNeighbor, Dev_NNearestNeighbor, NClusters * sizeof(int), cudaMemcpyDeviceToHost);
!
!	cudaEventDestroy(StartEvent);
!	cudaEventDestroy(StopEvent);
!}


  subroutine Host_CheckSort_Test(MulitBox,MaxSegmentsNumberEachBox,IDSEArray_ForSort,DevClusters,Dev_IDSEArray,SortedIndex_Dev)
    implicit none
    !---Dummy Vars---
    integer::MulitBox
    integer::MaxSegmentsNumberEachBox
    integer,dimension(:,:),allocatable::IDSEArray_ForSort
    type(ACluster),device,dimension(:),allocatable::DevClusters
    integer,device,dimension(:,:),allocatable::Dev_IDSEArray
    integer,device,dimension(:),allocatable::SortedIndex_Dev
    !---Local Vars---
    type(ACluster),dimension(:),allocatable::HostClusters
    integer,dimension(:,:),allocatable::Host_IDSEArray
    integer::NSize
    integer::IBox
    integer::ICFrom
    integer::ICTo
    type(ACluster)::tempCluster
    integer::temp
    integer::IC,JC
    integer,dimension(:),allocatable::Host_MySortedIndexArray
    integer,dimension(:),allocatable::Host_OutSortedIndexArray
    integer::ISegment
    !---Body---
    NSize = size(DevClusters)

    call AllocateArray_Host(HostClusters,NSize,"HostClusters")
    HostClusters = DevClusters

    call AllocateArray_Host(Host_IDSEArray,MulitBox,2,"Host_IDSEArray")

    Host_IDSEArray = Dev_IDSEArray

    call AllocateArray_Host(Host_OutSortedIndexArray,NSize,"Host_OutSortedIndexArray")

    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)


        DO IC = ICFrom,ICTo
            Host_OutSortedIndexArray(IC) = IC
        END DO

        DO IC = ICFrom,ICTo
            DO JC=IC,ICTo

                if(HostClusters(Host_OutSortedIndexArray(IC))%m_POS(1) .GT. HostClusters(Host_OutSortedIndexArray(JC))%m_POS(1)) then
                    temp = Host_OutSortedIndexArray(IC)
                    Host_OutSortedIndexArray(IC) = Host_OutSortedIndexArray(JC)
                    Host_OutSortedIndexArray(JC) = temp
                end if

            END DO

        END DO
    END DO


    call AllocateArray_Host(Host_MySortedIndexArray,NSize,"Host_MySortedIndexArray")
    Host_MySortedIndexArray = SortedIndex_Dev

    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)
        write(*,*) "******************IBox********************",IBox

        DO IC = ICFrom,ICTo

            if(Host_MySortedIndexArray(IC) .ne. Host_OutSortedIndexArray(IC)) then
                write(*,*) "It is wrong for index: ",IC
                write(*,*) Host_MySortedIndexArray(IC),Host_OutSortedIndexArray(IC)


                write(*,*) "******************My sort method******************"
                DO ISegment = (IBox - 1)*MaxSegmentsNumberEachBox +1,IBox*MaxSegmentsNumberEachBox
                    write(*,*) "ISegment",ISegment,IDSEArray_ForSort(ISegment,1),IDSEArray_ForSort(ISegment,2)
                END DO
                DO JC = ICFrom,ICTo
                    write(*,*) JC,Host_MySortedIndexArray(JC),HostClusters(Host_MySortedIndexArray(JC))%m_POS(1)
                END DO

                write(*,*) "******************CPU sort method******************"
                DO JC = ICFrom,ICTo
                    write(*,*) JC,Host_OutSortedIndexArray(JC),HostClusters(Host_OutSortedIndexArray(JC))%m_POS(1)
                END DO

                pause
            end if

        END DO
    END DO

    return
  end subroutine

  !******************************************************************
  subroutine CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    type(ACluster),dimension(:),allocatable::HostClusters
    integer,dimension(:,:),allocatable::Host_IDSEArray
    integer::NSize
    integer::IBox
    integer::ICFrom
    integer::ICTo
    integer::temp
    integer::IC,JC
    integer,dimension(:),allocatable::Host_KVOIS_MyMethod
    integer,dimension(:),allocatable::Host_KVOIS_BeforeMethod
    integer,dimension(:,:),allocatable::Host_INDI_MyMethod
    integer,dimension(:,:),allocatable::Host_INDI_BeforeMethod
    real(kind=KINDDF),dimension(:),allocatable::Host_MinTSteps_MyMethod
    real(kind=KINDDF),dimension(:),allocatable::Host_MinTSteps_BeforeMethod
    integer::MulitBox
    real(kind=KINDDF)::Distance
    real(kind=KINDDF)::reactTime
    !---Body---
    MulitBox = Host_SimuCtrlParam%MultiBox

    NSize = size(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    call AllocateArray_Host(HostClusters,NSize,"HostClusters")
    HostClusters = Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters

    call AllocateArray_Host(Host_IDSEArray,MulitBox,2,"Host_IDSEArray")

    Host_IDSEArray = Dev_Boxes%dm_SEExpdIndexBox

    call AllocateArray_Host(Host_KVOIS_MyMethod,NSize,"Host_KVOIS_MyMethod")
    Host_KVOIS_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS

    call AllocateArray_Host(Host_INDI_MyMethod,NSize,1,"Host_INDI_MyMethod")
    Host_INDI_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI

    call AllocateArray_Host(Host_MinTSteps_MyMethod,NSize,"Host_MinTSteps_MyMethod")
    Host_MinTSteps_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps


    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    call AllocateArray_Host(Host_KVOIS_BeforeMethod,NSize,"Host_KVOIS_BeforeMethod")
    Host_KVOIS_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS

    call AllocateArray_Host(Host_INDI_BeforeMethod,NSize,1,"Host_INDI_BeforeMethod")
    Host_INDI_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI

    call AllocateArray_Host(Host_MinTSteps_BeforeMethod,NSize,"Host_MinTSteps_BeforeMethod")
    Host_MinTSteps_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps



    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)

        DO IC = ICFrom,ICTo
            if(Host_INDI_BeforeMethod(IC,1) .ne. Host_INDI_MyMethod(IC,1)) then
                write(*,*) "******************IBox********************",IBox

                write(*,*) "The neighbor is not true for index: ",IC,Host_INDI_BeforeMethod(IC,1),Host_INDI_MyMethod(IC,1)

                Distance = (HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(1))*(HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(1)) + &
                           (HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(2))*(HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(2)) + &
                           (HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(3))*(HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(3))


                Distance = DSQRT(Distance) - HostClusters(IC)%m_RAD - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_RAD
                reactTime = (Distance*Distance)*(1.D0/6.D0)/(HostClusters(IC)%m_DiffCoeff + HostClusters(Host_INDI_BeforeMethod(IC,1))%m_DiffCoeff + 2*SQRT(HostClusters(IC)%m_DiffCoeff*HostClusters(Host_INDI_BeforeMethod(IC,1))%m_DiffCoeff ))
                write(*,*) "Distance Before method",Distance,"reaction time",reactTime


                Distance = (HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(1))*(HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(1)) + &
                           (HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(2))*(HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(2)) + &
                           (HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(3))*(HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(3))


                Distance = DSQRT(Distance) - HostClusters(IC)%m_RAD - HostClusters(Host_INDI_MyMethod(IC,1))%m_RAD
                reactTime = (Distance*Distance)*(1.D0/6.D0)/(HostClusters(IC)%m_DiffCoeff + HostClusters(Host_INDI_MyMethod(IC,1))%m_DiffCoeff + 2*SQRT(HostClusters(IC)%m_DiffCoeff*HostClusters(Host_INDI_MyMethod(IC,1))%m_DiffCoeff ))
                write(*,*) "Distance my method",Distance,"reaction time",reactTime

                write(*,*) Host_MinTSteps_BeforeMethod(IC),Host_MinTSteps_MyMethod(IC)
                pause
            end if


        END DO
    END DO

    call DeAllocateArray_Host(HostClusters,"HostClusters")
    call DeAllocateArray_Host(Host_IDSEArray,"Host_IDSEArray")
    call DeAllocateArray_Host(Host_KVOIS_MyMethod,"Host_KVOIS_MyMethod")
    call DeAllocateArray_Host(Host_KVOIS_BeforeMethod,"Host_KVOIS_BeforeMethod")
    call DeAllocateArray_Host(Host_INDI_MyMethod,"Host_INDI_MyMethod")
    call DeAllocateArray_Host(Host_INDI_BeforeMethod,"Host_INDI_BeforeMethod")
    call DeAllocateArray_Host(Host_MinTSteps_MyMethod,"Host_MinTSteps_MyMethod")
    call DeAllocateArray_Host(Host_MinTSteps_BeforeMethod,"Host_MinTSteps_BeforeMethod")
    return
  end subroutine


  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)


    call Dev_Boxes%dm_BitionicSort%Sort(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndex_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    else
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndex_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    end if

    call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)


  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen


end module MCLIB_CAL_NEIGHBOR_LIST_GPU
