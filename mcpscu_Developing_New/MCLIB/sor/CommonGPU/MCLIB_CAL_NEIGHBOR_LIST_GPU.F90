!  Free-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  9/24/2017 11:29:00 PM
module MCLIB_CAL_NEIGHBOR_LIST_GPU

  use cudafor
  use MCLIB_TYPEDEF_SIMULATIONBOXARRAY_GPU
  use MODEL_ECR_GPU

  implicit none

  integer,private,parameter::p_BLOCKSIZE_MyMethod = 128

  !------Vars--------------
  integer,private,parameter::p_MXNEAREST = 2048                                         ! the pre-allocated number for nearest around neighborhood(which is used for
                                                                                        ! the default pre-allocated number in device,actual number for nearest around
                                                                                        ! neighborhood is defined by the m_NeighborNum which givend by
                                                                                        ! the user control file)

  real(kind=KINDDF),private,device,dimension(:,:),allocatable::dm_CumulateSep
  real(kind=KINDDF),private,dimension(:,:),allocatable::m_CumulateSep
  integer,private,device,dimension(:,:),allocatable::dm_CumulateSepCount
  integer,private,dimension(:,:),allocatable::m_CumulateSepCount

  contains
  !**********************************************************************************
  subroutine Cal_Neighbor_List_GPU(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,Record,IfDirectly,RMAX,MaxDiffuse)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    CLASS(SimulationRecord)::Record
    logical,optional::IfDirectly
    real(kind=KINDDF),optional::RMAX
    real(kind=KINDDF),optional::MaxDiffuse
    !---Local Vars---
    logical::SureToUpdateNL
    integer::NAct
    !---Body---

    if(Host_SimuCtrlParam%FreeDiffusion .eq. .true.) then
        return
    end if

    SureToUpdateNL = .false.

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + &
           Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    if(present(IfDirectly)) then
        if(IfDirectly .eq. .true.) then
            SureToUpdateNL = .true.
        end if
    end if

    if(SureToUpdateNL .eq. .false.) then
        select case(Host_SimuCtrlParam%NEIGHBORUPDATESTRATEGY)
            case(mp_NEIGHBORUPDATEBYNCREMIND)
                if(dble(NAct)/dble(Record%GetLastUpdateNLNC0()) .LE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                        SureToUpdateNL = .true.
                end if
            case(mp_NEIGHBORUPDATEBYSTEP)
                if((Record%GetSimuSteps() - Record%GetLastUpdateNLTime()) .GE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                    SureToUpdateNL = .true.
                end if
        end select
    end if

    if(SureToUpdateNL .eq. .true.) then

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR .or.   &
           Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR_LastPassage_Integer) then

           select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
           end select

        else
            select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    if(.not. present(RMAX)) then
                        write(*,*) "MCPSCUERROR: Must special the max radius if the cut-off neighbor-list is used."
                        pause
                        stop
                    end if
                    call Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
            end select
        end if

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NearestSep) then
            call CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        end if

        call Record%SetLastUpdateNLNC0(NAct)
        call Record%SetLastUpdateNLTime((dble(Record%GetSimuSteps())))

        call Dev_Boxes%dm_ClusterInfo_GPU%IncreaseOneNLUpdateCount_Dev()
    end if

    return
  end subroutine Cal_Neighbor_List_GPU

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam        , the user defined number of nearest neighborhood
    !             Dev_Boxes                , boxes information in device
    !             RCUT                     , the cu-off radius of calculating neighbores
    !
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::RMAX
    !---Local Vars---
    integer::MultiBox
    type(dim3) :: blocks
    type(dim3) :: threads
    integer::NB, NBX, NBY, BX, BY, err
    real(kind=KINDDF)::RCUT,RCUT2
    integer::BlockNumEachBox
    integer::NNearestNeighbor
    logical, device::Dev_ExplosiveMerge
    logical::Host_ExplosiveMerge
    integer::NAct
    logical::ChangedToUsedIndex
    !---Body---

    #ifdef MC_PROFILING
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    call Time_Start(T_Cal_Neighbore_Table_GPU_Old_Start)
    #endif
    !---Body---
    ChangedToUsedIndex = .false.

    MultiBox = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if

    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    RCUT = Calc_RCUT_Old(Host_SimuCtrlParam%MultiBox,Host_SimuCtrlParam%CUTREGIONEXTEND,Host_Boxes%BOXVOLUM,NAct,RMAX)
    RCUT2 = RCUT*RCUT

    !DO I=1, NB
    !     IP = (I - 1)*p_BLOCKSIZE + 1
    !     IPM = min(IP + p_BLOCKSIZE - 1, NC)
    !     call DEV_Cal_Neighbore_Table<<<blocks,threads>>>(NC, DSIZE, Dev_Clusters,RCUT2, IP, IPM, Dev_NeighborKVOIS,dm_INDI)
    !END DO
    !--------New Version,the divide operation is included in the core fuction------

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEExpdIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     else
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEUsedIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     end if


    err = cudaThreadSynchronize()

    !call GetMaxNeighborhoods_RCUT(TNC,Dev_NeighborKVOIS)

    Host_ExplosiveMerge = Dev_ExplosiveMerge

    if(Host_ExplosiveMerge .eq. .true.) then
        write(*,*) "MCPSCUERROR: There are explosive clusters growth happened."
        pause
        stop
    end if

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Old_Start,T_Cal_Neighbore_Table_GPU_Old)
    #endif
    return
  end subroutine Cal_Neighbore_Table_GPU_Old

  !******************************************************************
  attributes(global) subroutine Kernel_NeighborList_Rcut(MAXNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,RCUT2,Dev_ExplosiveMerge,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             MAXNeighbor           , the user defined number of  neighborhoods
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index of cluster used for neighbor-list calculation in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    !             RCUT2                 , the pow2 of cut-off distance
    !             Dev_ExplosiveMerge    , the explosive statu
    implicit none
    !
    !---Dummy Vars---
    integer,value::MAXNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    real(kind=KINDDF), value::RCUT2
    logical,device::Dev_ExplosiveMerge
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IS,IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DIST2
    integer::NN
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
         Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
         Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
         Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
         Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. MAXNeighbor) then
                    if(DIST2 .LE. RCUT2) then
                      NN = NN + 1
                      KVOIS(IC) = NN
                      INDI(IC,NN) = I
                    end if
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_RCUT


  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox

    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEActIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEActIndexBox(:,1)))/p_BLOCKSIZE + 1
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    call Kernel_NeighborList_Nearest_WithActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                  &
                                                                         Dev_Boxes%dm_SEExpdIndexBox,      &
                                                                         Dev_Boxes%dm_SEActIndexBox,        &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_ActiveIndex,   &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS, &
                                                                         BlockNumEachBox)

    err = cudaThreadSynchronize()

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithActiveIndex(NNearestNeighbor,Dev_SEExpdIndexBox,Dev_SEActIndexBox, &
                                                                            Dev_Clusters,Dev_ActiveIndex,INDI,KVOIS,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters  that need to calculate the neighbor-list in each box
    !             Dev_SEActIndexBox     , start and end active clusters index for each box
    !             Dev_Clusters          , clusters array
    !             Dev_ActiveIndex       , the active clusters index in device
    !             INDI                  , the index list of the neighbores
    !             KVOIS                 , the number of neighbores of clusters

    implicit none
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer, device::Dev_SEActIndexBox(:,:)
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_ActiveIndex(:)
    integer,device::INDI(:,:)
    integer,device::KVOIS(:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    integer::mappedIndex,mapped_SharedIndex
    integer::eActId
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    mappedIndex = Dev_ActiveIndex(IC)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(mappedIndex .LE. ecid) then
        Pos_x = Dev_Clusters(mappedIndex)%m_POS(1)
        Pos_y = Dev_Clusters(mappedIndex)%m_POS(2)
        Pos_z = Dev_Clusters(mappedIndex)%m_POS(3)
        STATU = Dev_Clusters(mappedIndex)%m_Statu
        KVOIS(mappedIndex) = 0
    end if

    ICFROM = scid
    eActId = scid + Dev_SEActIndexBox(IB,2) - Dev_SEActIndexBox(IB,1)
    ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

    DO while(ICTO .GE. ICFROM)

       if((ICFROM+tid-1) .LE. ecid) then
         mapped_SharedIndex = Dev_ActiveIndex(ICFROM+tid-1)

         if(mapped_SharedIndex .LE. ecid) then
           Shared_Statu(tid) = Dev_Clusters(mapped_SharedIndex)%m_Statu
           Shared_PosX(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(1)
           Shared_PosY(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(2)
           Shared_PosZ(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(3)
         end if
       end if

       call syncthreads()

       IF(mappedIndex .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then  ! it is true for IC, not mappedIndex

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(mappedIndex) = NN
                    INDI(mappedIndex,NN) = Dev_ActiveIndex(I)
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = Dev_ActiveIndex(I)
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    else
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    end if


    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = I
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    else
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    end if

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,MinTSteps)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    real(kind=KINDDF),device::MinTSteps(:)
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_DiffCoeff
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_RR
    integer,shared,dimension(p_BLOCKSIZE)::Shared_NSIA
    integer,shared,dimension(p_BLOCKSIZE)::Shared_NVAC
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_Time
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxTime,temp_Time
    integer::Nearest_maxTimeIndex
    real(kind=KINDDF)::MinT,reactTime
    integer::NN
    integer::NSIAIC,NVACIC
    integer::NSIAJC,NVACJC
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxTime=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        DiffA = Dev_Clusters(IC)%m_DiffCoeff
        RADA = Dev_Clusters(IC)%m_RAD
        KVOIS(IC) = 0

        MinTSteps(IC) = 1.D32

        NSIAIC = Dev_Clusters(IC)%m_Atoms(dm_SIA_Index_W)%m_NA
        NVACIC = Dev_Clusters(IC)%m_Atoms(dm_Vac_Index_W)%m_NA
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    MinT = 1.D32

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
        Shared_DiffCoeff(tid) = Dev_Clusters(ICFROM+tid-1)%m_DiffCoeff
        Shared_RR(tid) = Dev_Clusters(ICFROM+tid-1)%m_RAD
        Shared_NSIA(tid) = Dev_Clusters(ICFROM+tid-1)%m_Atoms(dm_SIA_Index_W)%m_NA
        Shared_NVAC(tid) = Dev_Clusters(ICFROM+tid-1)%m_Atoms(dm_Vac_Index_W)%m_NA
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then

                 NSIAJC = Shared_NSIA(JC)
                 NVACJC = Shared_NVAC(JC)
                  if(NSIAIC*NVACJC .LE. 0 .AND. NVACIC*NSIAJC .LE. 0) then
                    cycle
                  end if

                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  RADB = Shared_RR(JC)

                  DiffB = Shared_DiffCoeff(JC)

                  DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                  reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time


                  if(reactTime .LE. MinT ) then
                    MinT = reactTime
                  end if

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_Time(NN) = reactTime

                    if(Nearest_maxTime .LT. reactTime) then

                      Nearest_maxTime = reactTime
                      Nearest_maxTimeIndex = NN
                    end if

                  else if(Nearest_maxTime .GT. reactTime) then

                    INDI(IC,Nearest_maxTimeIndex) = I
                    Nearest_Time(Nearest_maxTimeIndex) = reactTime
                    Nearest_maxTime = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_Time = Nearest_Time(K)
                      if(temp_Time .GT. Nearest_maxTime) then

                        Nearest_maxTime = temp_Time
                        Nearest_maxTimeIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    if(IC .LE. ecid) then
        MinTSteps(IC) = MinT
    end if

    return
  end subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex

  !********************************************************
  subroutine CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        ! Note: this subroutine relate one the neighbor-list in GPU, please ensure that neighbor-list had been stored in Dev_Boxes
        implicit none
        !---Dummy Vars---
        type(SimulationBoxes)::Host_Boxes
        type(SimulationCtrlParam)::Host_SimuCtrlParam
        type(SimulationBoxes_GPU)::Dev_Boxes
        !---Local Vars---
        integer::MULTIBOX
        integer::BlockNumEachBox
        integer::BlockNumEachBoxExpd,BlockNumEachBoxVirtual
        type(dim3)::blocks
        type(dim3)::threads
        integer::NBExpd,NBVirtual
        integer::BX,BY,NB,err
        integer::NBAllocate
        integer::NCActFreeClusters
        integer::NCActFreeClustersEachBox
        integer::NCActGBClusters
        integer::NCActGBClustersEachBox
        integer::IBox
        integer::IBFROM
        integer::IBTO
        !---Body---
        ASSOCIATE(Dev_ClusterInfo_GPU=>Dev_Boxes%dm_ClusterInfo_GPU)

            MULTIBOX = Host_SimuCtrlParam%MultiBox

            if(maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)) .LT. 0) then
                return
            end if

            BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NB = BlockNumEachBox*MultiBox

            BlockNumEachBoxExpd = (maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBExpd = BlockNumEachBoxExpd*MultiBox

            BlockNumEachBoxVirtual = (maxval(Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBVirtual = BlockNumEachBoxVirtual*MultiBox

            !---Here, the array size is domain by the virtual or expd situation, for used situation,
            !   The array size maybe a little bigger than used size
            !   The main purpose to let what happen is that we do not want to allocate a suitable memory size
            !   for used situation in each step, because for implant, the used size is keeping changing and we should not adjustment below
            !   memory each step, so we use the virtual or expd size, which mean, while GetBoxesMigCoaleStat_Expd_GPU or
            !   GetBoxesMigCoaleStat_Virtual_GPU is used, we had get a bigger block of memory size that can ensure the usage
            !   for next N steps and need not to adjustment memory size.
            NBAllocate = max(NB,NBExpd,NBVirtual)

            if(.not. allocated(m_CumulateSep)) then
                allocate(m_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSep,dim=2)) then
                deallocate(m_CumulateSep)
                allocate(m_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSep)) then
                allocate(dm_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSep,dim=2)) then
                deallocate(dm_CumulateSep)
                allocate(dm_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(m_CumulateSepCount)) then
                allocate(m_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSepCount,dim=2)) then
                deallocate(m_CumulateSepCount)
                allocate(m_CumulateSepCount(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSepCount)) then
                allocate(dm_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSepCount,dim=2)) then
                deallocate(dm_CumulateSepCount)
                allocate(dm_CumulateSepCount(2,NBAllocate))
            end if

            !*** to determine the block size
            BX = p_Reduce_BLOCKSIZE
            BY = 1
            !*** to determine the dimension of blocks

            blocks  = dim3(NB, 1, 1)
            threads = dim3(BX, BY, 1)

            call CalSep_Kernel<<<blocks,threads>>>(BlockNumEachBox,                    &
                                                   Dev_ClusterInfo_GPU%dm_Clusters,    &
                                                   Dev_Boxes%dm_SEUsedIndexBox,        &
                                                   Dev_ClusterInfo_GPU%dm_KVOIS,       &
                                                   Dev_ClusterInfo_GPU%dm_INDI,        &
                                                   dm_CumulateSepCount,                &
                                                   dm_CumulateSep)

            m_CumulateSepCount = dm_CumulateSepCount

            m_CumulateSep  = dm_CumulateSep

            DO IBox = 1,MULTIBOX
                IBFROM = (IBox -1)*BlockNumEachBox + 1
                IBTO = IBox*BlockNumEachBox

                NCActFreeClustersEachBox = sum(m_CumulateSepCount(1,IBFROM:IBTO))
                if(NCActFreeClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,IBFROM:IBTO))/NCActFreeClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if

                NCActGBClustersEachBox = sum(m_CumulateSepCount(2,IBFROM:IBTO))
                if(NCActGBClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = sum(m_CumulateSep(2,IBFROM:IBTO))/NCActGBClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if
            END DO

            NCActFreeClusters = sum(m_CumulateSepCount(1,1:NB))
            if(NCActFreeClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,1:NB))/NCActFreeClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

            NCActGBClusters = sum(m_CumulateSepCount(2,1:NB))
            if(NCActGBClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = sum(m_CumulateSep(2,1:NB))/NCActGBClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

        END ASSOCIATE
        return
  end subroutine CalClustersSep_Dev

  !********************************************************
  attributes(global) subroutine CalSep_Kernel(BlockNumEachBox,Dev_Clusters,Dev_SEUsedIndexBox,Neighbor_KVOIS,Neighbor_INDI,CumulateSepCount,CumulateSep)
        implicit none
        !---Dummy Vars---
        integer,value::BlockNumEachBox
        type(Acluster),device::Dev_Clusters(:)
        integer,device::Dev_SEUsedIndexBox(:,:)
        integer,device::Neighbor_KVOIS(:)
        integer,device::Neighbor_INDI(:,:)
        integer,device::CumulateSepCount(2,*)
        real(kind=KINDDF),device::CumulateSep(2,*)
        !---Local Vars---
        integer::tid,bid,bid0,cid
        integer::IC
        integer::IBox
        integer::scid,ecid
        real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z
        real(kind=KINDSF)::Sep_X,Sep_Y,Sep_Z
        real(kind=KINDSF)::RADA,RADB,DIST,RR
        integer::N_Neighbor
        integer::I,J,JC
        real(kind=KINDDF)::MinDist
        real(kind=KINDDF),shared::Share_CumulateSep(p_Reduce_BLOCKSIZE)
        integer,shared::Share_CumulateSepCount(p_Reduce_BLOCKSIZE)
        !---Body---
        tid = (threadidx%y - 1)*blockdim%x + threadidx%x
        bid = (blockidx%y  - 1)*griddim%x  + blockidx%x
        cid = (bid -1)*p_Reduce_BLOCKSIZE + tid

        IBox = (bid - 1)/BlockNumEachBox + 1

        bid0 = (IBox - 1)*BlockNumEachBox

        scid = Dev_SEUsedIndexBox(IBox,1)

        ecid = Dev_SEUsedIndexBox(IBox,2)

        IC = scid + (cid - bid0*p_Reduce_BLOCKSIZE -1)

        !----For p_ACTIVEFREE_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEFREE_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEFREE_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if


        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(1,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(1,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        call syncthreads()

        !----For p_ACTIVEGB_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEINGB_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEINGB_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if

        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(2,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(2,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        return
  end subroutine CalSep_Kernel


end module MCLIB_CAL_NEIGHBOR_LIST_GPU
