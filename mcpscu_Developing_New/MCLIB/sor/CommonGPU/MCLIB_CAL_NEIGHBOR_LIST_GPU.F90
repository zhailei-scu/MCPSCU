!  Free-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  9/24/2017 11:29:00 PM
module MCLIB_CAL_NEIGHBOR_LIST_GPU

  use cudafor
  use MCLIB_TYPEDEF_SIMULATIONBOXARRAY_GPU

  implicit none

  integer,private,parameter::p_BLOCKSIZE_MyMethod = 128

  !------Vars--------------
  integer,private,parameter::p_MXNEAREST = 2048                                         ! the pre-allocated number for nearest around neighborhood(which is used for
                                                                                        ! the default pre-allocated number in device,actual number for nearest around
                                                                                        ! neighborhood is defined by the m_NeighborNum which givend by
                                                                                        ! the user control file)

  real(kind=KINDDF),private,device,dimension(:,:),allocatable::dm_CumulateSep
  real(kind=KINDDF),private,dimension(:,:),allocatable::m_CumulateSep
  integer,private,device,dimension(:,:),allocatable::dm_CumulateSepCount
  integer,private,dimension(:,:),allocatable::m_CumulateSepCount

  integer::TheFlag = 0

  integer,device,dimension(:,:),allocatable::dm_SEIndex_ForCell
  integer,dimension(:,:),allocatable::m_SEIndex_ForCell

  contains
  !**********************************************************************************
  subroutine Cal_Neighbor_List_GPU(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,Record,IfDirectly,RMAX,MaxDiffuse)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    CLASS(SimulationRecord)::Record
    logical,optional::IfDirectly
    real(kind=KINDDF),optional::RMAX
    real(kind=KINDDF),optional::MaxDiffuse
    !---Local Vars---
    logical::SureToUpdateNL
    integer::NAct
    !---Body---

    if(Host_SimuCtrlParam%FreeDiffusion .eq. .true.) then
        return
    end if

    SureToUpdateNL = .false.

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + &
           Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    if(present(IfDirectly)) then
        if(IfDirectly .eq. .true.) then
            SureToUpdateNL = .true.
        end if
    end if

    if(SureToUpdateNL .eq. .false.) then
        select case(Host_SimuCtrlParam%NEIGHBORUPDATESTRATEGY)
            case(mp_NEIGHBORUPDATEBYNCREMIND)
                if(dble(NAct)/dble(Record%GetLastUpdateNLNC0()) .LE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                        SureToUpdateNL = .true.
                end if
            case(mp_NEIGHBORUPDATEBYSTEP)
                if((Record%GetSimuSteps() - Record%GetLastUpdateNLTime()) .GE. Host_SimuCtrlParam%NEIGHBORUPDATE) then
                    SureToUpdateNL = .true.
                end if
        end select
    end if

    if(SureToUpdateNL .eq. .true.) then

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR .or.   &
           Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NNDR_LastPassage_Integer) then

           select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_SortX)
                    if(.not. present(MaxDiffuse)) then
                        write(*,*) "MCPSCUERROR: Must special the max diffusor if the SortX neighbor-list is used."
                        pause
                        stop
                    end if
                    call Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
           end select

        else
            select case(Host_SimuCtrlParam%NEIGHBORCALWAY)
                case(mp_CalcNeighborList_NNEAREST)
                    call Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
                case(mp_CalcNeighborList_RCUT)
                    if(.not. present(RMAX)) then
                        write(*,*) "MCPSCUERROR: Must special the max radius if the cut-off neighbor-list is used."
                        pause
                        stop
                    end if
                    call Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
                case default
                    write(*,*) "MCPSCUERROR: Unknown strategy to update neighbor-list."
                    pause
                    stop
            end select
        end if

        if(Host_SimuCtrlParam%UPDATETSTEPSTRATEGY .eq. mp_SelfAdjustlStep_NearestSep) then
            call CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        end if

        call Record%SetLastUpdateNLNC0(NAct)
        call Record%SetLastUpdateNLTime((dble(Record%GetSimuSteps())))

        call Dev_Boxes%dm_ClusterInfo_GPU%IncreaseOneNLUpdateCount_Dev()
    end if

    return
  end subroutine Cal_Neighbor_List_GPU

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Old(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,RMAX)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam        , the user defined number of nearest neighborhood
    !             Dev_Boxes                , boxes information in device
    !             RCUT                     , the cu-off radius of calculating neighbores
    !
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::RMAX
    !---Local Vars---
    integer::MultiBox
    type(dim3) :: blocks
    type(dim3) :: threads
    integer::NB, NBX, NBY, BX, BY, err
    real(kind=KINDDF)::RCUT,RCUT2
    integer::BlockNumEachBox
    integer::NNearestNeighbor
    logical, device::Dev_ExplosiveMerge
    logical::Host_ExplosiveMerge
    integer::NAct
    logical::ChangedToUsedIndex
    !---Body---

    #ifdef MC_PROFILING
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    call Time_Start(T_Cal_Neighbore_Table_GPU_Old_Start)
    #endif
    !---Body---
    ChangedToUsedIndex = .false.

    MultiBox = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if

    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    NAct = Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEFREE_STATU) + Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%NC(p_ACTIVEINGB_STATU)

    RCUT = Calc_RCUT_Old(Host_SimuCtrlParam%MultiBox,Host_SimuCtrlParam%CUTREGIONEXTEND,Host_Boxes%BOXVOLUM,NAct,RMAX)
    RCUT2 = RCUT*RCUT

    !DO I=1, NB
    !     IP = (I - 1)*p_BLOCKSIZE + 1
    !     IPM = min(IP + p_BLOCKSIZE - 1, NC)
    !     call DEV_Cal_Neighbore_Table<<<blocks,threads>>>(NC, DSIZE, Dev_Clusters,RCUT2, IP, IPM, Dev_NeighborKVOIS,dm_INDI)
    !END DO
    !--------New Version,the divide operation is included in the core fuction------

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEExpdIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     else
        call Kernel_NeighborList_Rcut<<<blocks,threads>>>(NNearestNeighbor,                         &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters, &
                                                          Dev_Boxes%dm_SEUsedIndexBox,              &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,    &
                                                          Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,     &
                                                          RCUT2,                                    &
                                                          Dev_ExplosiveMerge,                       &
                                                          BlockNumEachBox)
     end if


    err = cudaThreadSynchronize()

    !call GetMaxNeighborhoods_RCUT(TNC,Dev_NeighborKVOIS)

    Host_ExplosiveMerge = Dev_ExplosiveMerge

    if(Host_ExplosiveMerge .eq. .true.) then
        write(*,*) "MCPSCUERROR: There are explosive clusters growth happened."
        pause
        stop
    end if

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Old_Start,T_Cal_Neighbore_Table_GPU_Old)
    #endif
    return
  end subroutine Cal_Neighbore_Table_GPU_Old

  !******************************************************************
  attributes(global) subroutine Kernel_NeighborList_Rcut(MAXNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,RCUT2,Dev_ExplosiveMerge,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             MAXNeighbor           , the user defined number of  neighborhoods
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index of cluster used for neighbor-list calculation in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    !             RCUT2                 , the pow2 of cut-off distance
    !             Dev_ExplosiveMerge    , the explosive statu
    implicit none
    !
    !---Dummy Vars---
    integer,value::MAXNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    real(kind=KINDDF), value::RCUT2
    logical,device::Dev_ExplosiveMerge
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IS,IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DIST2
    integer::NN
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
         Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
         Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
         Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
         Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. MAXNeighbor) then
                    if(DIST2 .LE. RCUT2) then
                      NN = NN + 1
                      KVOIS(IC) = NN
                      INDI(IC,NN) = I
                    end if
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_RCUT


  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox

    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEActIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEActIndexBox(:,1)))/p_BLOCKSIZE + 1
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    call Kernel_NeighborList_Nearest_WithActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                  &
                                                                         Dev_Boxes%dm_SEExpdIndexBox,      &
                                                                         Dev_Boxes%dm_SEActIndexBox,        &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_ActiveIndex,   &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS, &
                                                                         BlockNumEachBox)

    err = cudaThreadSynchronize()

    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithActiveIndex(NNearestNeighbor,Dev_SEExpdIndexBox,Dev_SEActIndexBox, &
                                                                            Dev_Clusters,Dev_ActiveIndex,INDI,KVOIS,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters  that need to calculate the neighbor-list in each box
    !             Dev_SEActIndexBox     , start and end active clusters index for each box
    !             Dev_Clusters          , clusters array
    !             Dev_ActiveIndex       , the active clusters index in device
    !             INDI                  , the index list of the neighbores
    !             KVOIS                 , the number of neighbores of clusters

    implicit none
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer, device::Dev_SEActIndexBox(:,:)
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_ActiveIndex(:)
    integer,device::INDI(:,:)
    integer,device::KVOIS(:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    integer::mappedIndex,mapped_SharedIndex
    integer::eActId
    !---Body---
    tid  = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid  = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid  = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    mappedIndex = Dev_ActiveIndex(IC)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(mappedIndex .LE. ecid) then
        Pos_x = Dev_Clusters(mappedIndex)%m_POS(1)
        Pos_y = Dev_Clusters(mappedIndex)%m_POS(2)
        Pos_z = Dev_Clusters(mappedIndex)%m_POS(3)
        STATU = Dev_Clusters(mappedIndex)%m_Statu
        KVOIS(mappedIndex) = 0
    end if

    ICFROM = scid
    eActId = scid + Dev_SEActIndexBox(IB,2) - Dev_SEActIndexBox(IB,1)
    ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

    DO while(ICTO .GE. ICFROM)

       if((ICFROM+tid-1) .LE. ecid) then
         mapped_SharedIndex = Dev_ActiveIndex(ICFROM+tid-1)

         if(mapped_SharedIndex .LE. ecid) then
           Shared_Statu(tid) = Dev_Clusters(mapped_SharedIndex)%m_Statu
           Shared_PosX(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(1)
           Shared_PosY(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(2)
           Shared_PosZ(tid) = Dev_Clusters(mapped_SharedIndex)%m_POS(3)
         end if
       end if

       call syncthreads()

       IF(mappedIndex .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN


         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then  ! it is true for IC, not mappedIndex

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(mappedIndex) = NN
                    INDI(mappedIndex,NN) = Dev_ActiveIndex(I)
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = Dev_ActiveIndex(I)
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,eActId)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    else
        call Kernel_NeighborList_Nearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                BlockNumEachBox)
    end if


    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_DIST2
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxDIST2,temp_DIST2
    integer::Nearest_maxDISTIndex
    integer::NN
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxDIST2=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        KVOIS(IC) = 0
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_DIST2(NN) = DIST2

                    if(Nearest_maxDIST2 .LT. DIST2) then

                      Nearest_maxDIST2 = DIST2
                      Nearest_maxDISTIndex = NN
                    end if

                  else if(Nearest_maxDIST2 .GT. DIST2) then

                    INDI(IC,Nearest_maxDISTIndex) = I
                    Nearest_DIST2(Nearest_maxDISTIndex) = DIST2
                    Nearest_maxDIST2 = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_DIST2 = Nearest_DIST2(K)
                      if(temp_DIST2 .GT. Nearest_maxDIST2) then

                        Nearest_maxDIST2 = temp_DIST2
                        Nearest_maxDISTIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    return
  end subroutine Kernel_NeighborList_Nearest_WithOutActiveIndex

  !**********************************************************************************
  subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::MULTIBOX
    integer::NNearestNeighbor
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY, err
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    type(cudaEvent)::StartEvent
    type(cudaEvent)::StopEvent
    integer::IState
    real::time
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    IState = cudaEventCreate(StartEvent)
    IState = cudaEventCreate(StopEvent)

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    NNearestNeighbor = Host_SimuCtrlParam%MAXNEIGHBORNUM

    !*** to determine the block size
    BX = p_BLOCKSIZE
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    if(NNearestNeighbor .GT. p_MXNEAREST) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is too large:",NNearestNeighbor,p_MXNEAREST
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    else if(NNearestNeighbor .LE. 0) then
       write(*,*) "Warning! The user defined number of nearest neighborhood is ZERO:",NNearestNeighbor
       NNearestNeighbor = p_MXNEAREST
       write(*,*) "To continue the evolution, the user defined number of nearest neighborhood is changed to:",NNearestNeighbor
    end if

    IState = cudaEventRecord(StartEvent,0)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEExpdIndexBox,                  &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    else
        call Kernel_NeighborList_TimeNearest_WithOutActiveIndex<<<blocks,threads>>>(NNearestNeighbor,                              &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                    Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                    BlockNumEachBox,                               &
                                                                                    Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps)
    end if

    IState = cudaEventRecord(StopEvent,0)

    IState = cudaEventSynchronize(StopEvent)

    IState = cudaEventElapsedTime(time,StartEvent,StopEvent)

    write(*,*) "NeighborCal time is: ",time

    IState = cudaEventDestroy(StartEvent)
    IState = cudaEventDestroy(StopEvent)


    #ifdef MC_PROFILING
    call Time_Accumulate(T_Cal_Neighbore_Table_GPU_Nearest_Start,T_Cal_Neighbore_Table_GPU_Nearest)
    #endif

    return
  end subroutine Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex

  !******************************************************************************************
  attributes(global) subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex(NNearestNeighbor,Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,MinTSteps)
    !***  PURPOSE:  to update the neighbore list of atoms(multiBox and block share tech is used)
    !             NNearestNeighbor      , the user defined number of nearest neighborhood
    !             Dev_Clusters          , clusters array
    !             Dev_SEExpdIndexBox   , array to record the start and end index range of clusters that would calculate the neighbor-lists in each box
    !             KVOIS                 , the number of neighbores of clusters
    !             INDI                  , the index list of the neighbores
    implicit none
    !
    !---Dummy Vars---
    integer,value::NNearestNeighbor
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    real(kind=KINDDF),device::MinTSteps(:)
    !---Local Vars---
    integer::tid,bid,IC0,cid,IB
    integer::scid,ecid
    integer::bid0
    integer::IC
    integer::ICFROM,ICTO
    integer::STATU
    integer::I,JC,K
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_PosX,Shared_PosY,Shared_PosZ
    integer,shared,dimension(p_BLOCKSIZE)::Shared_Statu
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_DiffCoeff
    real(kind=KINDSF),shared,dimension(p_BLOCKSIZE)::Shared_RR
    real(kind=KINDSF)::Pos_x,Pos_y,Pos_z,SEP_x,SEP_y,SEP_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF),dimension(p_MXNEAREST)::Nearest_Time
    real(kind=KINDSF)::DIST2
    real(kind=KINDSF)::Nearest_maxTime,temp_Time
    integer::Nearest_maxTimeIndex
    real(kind=KINDDF)::MinT,reactTime
    integer::NN
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    IC0 = (bid-1)*p_BLOCKSIZE + 1                         ! the first thread index of this block
    cid = IC0 + tid - 1                                  ! current thread index

    IB = (bid - 1)/BlockNumEachBox + 1
    bid0 = (IB - 1)*BlockNumEachBox + 1

    scid =  Dev_SEExpdIndexBox(IB,1)                  ! start search index
    ecid =  Dev_SEExpdIndexBox(IB,2)                  ! end   search index

    IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE - 1)

    NN = 0
    Nearest_maxTime=-1.D0

    if(IC .LE. ecid) then
        Pos_x = Dev_Clusters(IC)%m_POS(1)
        Pos_y = Dev_Clusters(IC)%m_POS(2)
        Pos_z = Dev_Clusters(IC)%m_POS(3)
        STATU = Dev_Clusters(IC)%m_Statu
        DiffA = Dev_Clusters(IC)%m_DiffCoeff
        RADA = Dev_Clusters(IC)%m_RAD
        KVOIS(IC) = 0

        MinTSteps(IC) = 1.D32
    end if

    ICFROM = scid
    ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

    MinT = 1.D32

    DO while(ICTO .GE. ICFROM)
       if((ICFROM+tid-1) .LE. ecid) then
        Shared_Statu(tid) = Dev_Clusters(ICFROM+tid-1)%m_Statu
        Shared_PosX(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(1)
        Shared_PosY(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(2)
        Shared_PosZ(tid) = Dev_Clusters(ICFROM+tid-1)%m_POS(3)
        Shared_DiffCoeff(tid) = Dev_Clusters(ICFROM+tid-1)%m_DiffCoeff
        Shared_RR(tid) = Dev_Clusters(ICFROM+tid-1)%m_RAD
       end if

       call syncthreads()

       IF(IC .LE. ecid .AND. (STATU .EQ. p_ACTIVEFREE_STATU .or. STATU .EQ. p_ACTIVEINGB_STATU)) THEN

         DO I = ICFROM, ICTO    ! mutual

             if(I .ne. IC) then

                JC = I - ICFROM + 1
                if(Shared_Statu(JC) .eq. p_ACTIVEFREE_STATU .or. Shared_Statu(JC) .eq. p_ACTIVEINGB_STATU) then
                  SEP_x = Pos_x - Shared_PosX(JC)
                  SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)

                  SEP_y = Pos_y - Shared_PosY(JC)
                  SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)

                  SEP_z = Pos_z - Shared_PosZ(JC)
                  SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)

                  DIST2 = SEP_x*SEP_x + SEP_y*SEP_y + SEP_z*SEP_z

                  RADB = Shared_RR(JC)

                  DiffB = Shared_DiffCoeff(JC)

                  DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                  reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time


                  if(reactTime .LE. MinT ) then
                    MinT = reactTime
                  end if

                  if(NN .LT. NNearestNeighbor) then

                    NN = NN + 1
                    KVOIS(IC) = NN
                    INDI(IC,NN) = I
                    Nearest_Time(NN) = reactTime

                    if(Nearest_maxTime .LT. reactTime) then

                      Nearest_maxTime = reactTime
                      Nearest_maxTimeIndex = NN
                    end if

                  else if(Nearest_maxTime .GT. reactTime) then

                    INDI(IC,Nearest_maxTimeIndex) = I
                    Nearest_Time(Nearest_maxTimeIndex) = reactTime
                    Nearest_maxTime = -1.0
                    DO K = 1,NNearestNeighbor
                      temp_Time = Nearest_Time(K)
                      if(temp_Time .GT. Nearest_maxTime) then

                        Nearest_maxTime = temp_Time
                        Nearest_maxTimeIndex = K
                      end if
                    END DO
                  end if

                end if
             end if
         END DO

      END IF

      ICFROM = ICTO + 1
      ICTO = min(ICFROM+p_BLOCKSIZE-1,ecid)

      call syncthreads()

    END DO

    if(IC .LE. ecid) then
        MinTSteps(IC) = MinT
    end if

    return
  end subroutine Kernel_NeighborList_TimeNearest_WithOutActiveIndex

  !********************************************************
  subroutine CalClustersSep_Dev(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
        ! Note: this subroutine relate one the neighbor-list in GPU, please ensure that neighbor-list had been stored in Dev_Boxes
        implicit none
        !---Dummy Vars---
        type(SimulationBoxes)::Host_Boxes
        type(SimulationCtrlParam)::Host_SimuCtrlParam
        type(SimulationBoxes_GPU)::Dev_Boxes
        !---Local Vars---
        integer::MULTIBOX
        integer::BlockNumEachBox
        integer::BlockNumEachBoxExpd,BlockNumEachBoxVirtual
        type(dim3)::blocks
        type(dim3)::threads
        integer::NBExpd,NBVirtual
        integer::BX,BY,NB,err
        integer::NBAllocate
        integer::NCActFreeClusters
        integer::NCActFreeClustersEachBox
        integer::NCActGBClusters
        integer::NCActGBClustersEachBox
        integer::IBox
        integer::IBFROM
        integer::IBTO
        !---Body---
        ASSOCIATE(Dev_ClusterInfo_GPU=>Dev_Boxes%dm_ClusterInfo_GPU)

            MULTIBOX = Host_SimuCtrlParam%MultiBox

            if(maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)) .LT. 0) then
                return
            end if

            BlockNumEachBox = (maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NB = BlockNumEachBox*MultiBox

            BlockNumEachBoxExpd = (maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBExpd = BlockNumEachBoxExpd*MultiBox

            BlockNumEachBoxVirtual = (maxval(Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEVirtualIndexBox(:,1)))/p_Reduce_BLOCKSIZE + 1
            NBVirtual = BlockNumEachBoxVirtual*MultiBox

            !---Here, the array size is domain by the virtual or expd situation, for used situation,
            !   The array size maybe a little bigger than used size
            !   The main purpose to let what happen is that we do not want to allocate a suitable memory size
            !   for used situation in each step, because for implant, the used size is keeping changing and we should not adjustment below
            !   memory each step, so we use the virtual or expd size, which mean, while GetBoxesMigCoaleStat_Expd_GPU or
            !   GetBoxesMigCoaleStat_Virtual_GPU is used, we had get a bigger block of memory size that can ensure the usage
            !   for next N steps and need not to adjustment memory size.
            NBAllocate = max(NB,NBExpd,NBVirtual)

            if(.not. allocated(m_CumulateSep)) then
                allocate(m_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSep,dim=2)) then
                deallocate(m_CumulateSep)
                allocate(m_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSep)) then
                allocate(dm_CumulateSep(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSep,dim=2)) then
                deallocate(dm_CumulateSep)
                allocate(dm_CumulateSep(2,NBAllocate))
            end if

            if(.not. allocated(m_CumulateSepCount)) then
                allocate(m_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(m_CumulateSepCount,dim=2)) then
                deallocate(m_CumulateSepCount)
                allocate(m_CumulateSepCount(2,NBAllocate))
            end if

            if(.not. allocated(dm_CumulateSepCount)) then
                allocate(dm_CumulateSepCount(2,NBAllocate))
            else if(NBAllocate .GT. size(dm_CumulateSepCount,dim=2)) then
                deallocate(dm_CumulateSepCount)
                allocate(dm_CumulateSepCount(2,NBAllocate))
            end if

            !*** to determine the block size
            BX = p_Reduce_BLOCKSIZE
            BY = 1
            !*** to determine the dimension of blocks

            blocks  = dim3(NB, 1, 1)
            threads = dim3(BX, BY, 1)

            call CalSep_Kernel<<<blocks,threads>>>(BlockNumEachBox,                    &
                                                   Dev_ClusterInfo_GPU%dm_Clusters,    &
                                                   Dev_Boxes%dm_SEUsedIndexBox,        &
                                                   Dev_ClusterInfo_GPU%dm_KVOIS,       &
                                                   Dev_ClusterInfo_GPU%dm_INDI,        &
                                                   dm_CumulateSepCount,                &
                                                   dm_CumulateSep)

            m_CumulateSepCount = dm_CumulateSepCount

            m_CumulateSep  = dm_CumulateSep

            DO IBox = 1,MULTIBOX
                IBFROM = (IBox -1)*BlockNumEachBox + 1
                IBTO = IBox*BlockNumEachBox

                NCActFreeClustersEachBox = sum(m_CumulateSepCount(1,IBFROM:IBTO))
                if(NCActFreeClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,IBFROM:IBTO))/NCActFreeClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if

                NCActGBClustersEachBox = sum(m_CumulateSepCount(2,IBFROM:IBTO))
                if(NCActGBClustersEachBox .GT. 0) then
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = sum(m_CumulateSep(2,IBFROM:IBTO))/NCActGBClustersEachBox
                else
                    Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Single(IBox)%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
                end if
            END DO

            NCActFreeClusters = sum(m_CumulateSepCount(1,1:NB))
            if(NCActFreeClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = sum(m_CumulateSep(1,1:NB))/NCActFreeClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeFreeClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

            NCActGBClusters = sum(m_CumulateSepCount(2,1:NB))
            if(NCActGBClusters .GT. 0) then
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = sum(m_CumulateSep(2,1:NB))/NCActGBClusters
            else
                Host_Boxes%m_BoxesBasicStatistic%BoxesStatis_Integral%AveNearestSpeGBClusters = minval(Host_Boxes%BOXSIZE)/2.D0
            end if

        END ASSOCIATE
        return
  end subroutine CalClustersSep_Dev

  !********************************************************
  attributes(global) subroutine CalSep_Kernel(BlockNumEachBox,Dev_Clusters,Dev_SEUsedIndexBox,Neighbor_KVOIS,Neighbor_INDI,CumulateSepCount,CumulateSep)
        implicit none
        !---Dummy Vars---
        integer,value::BlockNumEachBox
        type(Acluster),device::Dev_Clusters(:)
        integer,device::Dev_SEUsedIndexBox(:,:)
        integer,device::Neighbor_KVOIS(:)
        integer,device::Neighbor_INDI(:,:)
        integer,device::CumulateSepCount(2,*)
        real(kind=KINDDF),device::CumulateSep(2,*)
        !---Local Vars---
        integer::tid,bid,bid0,cid
        integer::IC
        integer::IBox
        integer::scid,ecid
        real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z
        real(kind=KINDSF)::Sep_X,Sep_Y,Sep_Z
        real(kind=KINDSF)::RADA,RADB,DIST,RR
        integer::N_Neighbor
        integer::I,J,JC
        real(kind=KINDDF)::MinDist
        real(kind=KINDDF),shared::Share_CumulateSep(p_Reduce_BLOCKSIZE)
        integer,shared::Share_CumulateSepCount(p_Reduce_BLOCKSIZE)
        !---Body---
        tid = (threadidx%y - 1)*blockdim%x + threadidx%x
        bid = (blockidx%y  - 1)*griddim%x  + blockidx%x
        cid = (bid -1)*p_Reduce_BLOCKSIZE + tid

        IBox = (bid - 1)/BlockNumEachBox + 1

        bid0 = (IBox - 1)*BlockNumEachBox

        scid = Dev_SEUsedIndexBox(IBox,1)

        ecid = Dev_SEUsedIndexBox(IBox,2)

        IC = scid + (cid - bid0*p_Reduce_BLOCKSIZE -1)

        !----For p_ACTIVEFREE_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEFREE_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEFREE_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if


        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(1,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(1,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        call syncthreads()

        !----For p_ACTIVEGB_STATU statu

        Share_CumulateSep(tid) = 0.D0
        Share_CumulateSepCount(tid) = 0

        if(IC .LE. ecid) then

            if(Dev_Clusters(IC)%m_Statu .eq. p_ACTIVEINGB_STATU) then
                MinDist = 1.D32

                Pos_X = Dev_Clusters(IC)%m_POS(1)
                Pos_Y = Dev_Clusters(IC)%m_POS(2)
                Pos_Z = Dev_Clusters(IC)%m_POS(3)

                RADA = Dev_Clusters(IC)%m_RAD

                N_Neighbor = Neighbor_KVOIS(IC)

                !scan the neighbor clusters
                DO J=1, N_Neighbor
                    JC = Neighbor_INDI(IC,J)

                    if(JC .GT. ecid) then
                        cycle
                    end if

                    if(Dev_Clusters(JC)%m_Statu .ne. p_ACTIVEINGB_STATU .or. IC .eq. JC) then
                        cycle
                    end if

                    Sep_X = Pos_X - Dev_Clusters(JC)%m_POS(1)
                    Sep_Y = Pos_Y - Dev_Clusters(JC)%m_POS(2)
                    Sep_Z = Pos_Z - Dev_Clusters(JC)%m_POS(3)

                    if(ABS(Sep_X) .GT. dm_HBOXSIZE(1) .AND. dm_PERIOD(1)) then
                        Sep_X = Sep_X - SIGN(dm_BOXSIZE(1),Sep_X)
                    end if

                    if(ABS(Sep_Y) .GT. dm_HBOXSIZE(2) .AND. dm_PERIOD(2)) then
                        Sep_Y = Sep_Y - SIGN(dm_BOXSIZE(2),Sep_Y)
                    end if

                    if(ABS(Sep_Z) .GT. dm_HBOXSIZE(3) .AND. dm_PERIOD(3)) then
                        Sep_Z = Sep_Z - SIGN(dm_BOXSIZE(3),Sep_Z)
                    end if

                    Sep_X = ABS(Sep_X)
                    Sep_Y = ABS(Sep_Y)
                    Sep_Z = ABS(Sep_Z)

                    RADB = Dev_Clusters(JC)%m_RAD

                    RR = RADA+RADB

                    DIST = SQRT(Sep_X*Sep_X + Sep_Y*Sep_Y + Sep_Z*Sep_Z) - RR
                    if(DIST .LE. 0) then
                        DIST = 0.D0
                    end if

                    if(MinDist .GT. DIST) then
                        MinDist = DIST
                        Share_CumulateSep(tid) = DIST
                        Share_CumulateSepCount(tid) = 1
                    end if

                END DO

            end if

        end if

        call syncthreads()

        if(tid .eq. 1) then
            CumulateSep(2,bid)  = sum(Share_CumulateSep,dim=1)
            CumulateSepCount(2,bid) = sum(Share_CumulateSepCount,dim=1)
        end if

        return
  end subroutine CalSep_Kernel


!__global__ void Kernel_MyNeighborListCal_SortX_multipleBox_noshare(int BlockNumEachBox, int **IDStartEnd_Dev, double** Dev_ClustersPosXYZ, int* SortedIndexX, int* Dev_NNearestNeighbor) {
!	int tid = threadIdx.y*blockDim.x + threadIdx.x;
!	int bid = blockIdx.y*gridDim.x + blockIdx.x;
!	int cid = bid * BLOCKSIZE + tid;
!	double Pos_X;
!	double Pos_Y;
!	double Pos_Z;
!	int MappedJC;
!	double distance;
!	double minDistance;
!	double distanceX;
!	double distanceY;
!	double distanceZ;
!	int NNID;
!	int MapedIdex;
!	int IBox;
!	int scid;
!	int ecid;
!	int bid0;
!	int IC;
!
!	IBox = bid / BlockNumEachBox;
!
!	scid = IDStartEnd_Dev[IBox][0];
!	ecid = IDStartEnd_Dev[IBox][1];
!
!	bid0 = IBox * BlockNumEachBox;
!
!	IC = scid + (cid - bid0 * BLOCKSIZE);
!
!	minDistance = 1.E32;
!
!	if (IC <= ecid) {
!
!		MapedIdex = SortedIndexX[IC];
!
!		Pos_X = Dev_ClustersPosXYZ[MapedIdex][0];
!		Pos_Y = Dev_ClustersPosXYZ[MapedIdex][1];
!		Pos_Z = Dev_ClustersPosXYZ[MapedIdex][2];
!
!		/*Right Hand Searching*/
!		for (int JC = IC + 1; JC <= ecid; JC++) {
!
!			MappedJC = SortedIndexX[JC];
!
!			distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!			distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!			distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!			distanceX = distanceX * distanceX;
!			distanceY = distanceY * distanceY;
!			distanceZ = distanceZ * distanceZ;
!
!			distance = distanceX + distanceY + distanceZ;
!
!			if (minDistance > distance) {
!				minDistance = distance;
!				NNID = MappedJC;
!			}
!
!			if (distanceX > minDistance) {
!				break;
!			}
!		}
!
!		/*Left Hand Searching*/
!		for (int JC = IC - 1; JC >= scid; JC--) {
!
!			MappedJC = SortedIndexX[JC];
!
!			distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!			distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!			distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!			distanceX = distanceX * distanceX;
!			distanceY = distanceY * distanceY;
!			distanceZ = distanceZ * distanceZ;
!
!			distance = distanceX + distanceY + distanceZ;
!
!			if (minDistance > distance) {
!				minDistance = distance;
!				NNID = MappedJC;
!			}
!
!			if (distanceX > minDistance) {
!				break;
!			}
!		}
!
!		Dev_NNearestNeighbor[MapedIdex] = NNID;
!	}
!}

  attributes(global) subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare(Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,SortedIndexX,MinTSteps,maxDiffuse)
    implicit none
    !--Dummy Vars---
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    integer,device::SortedIndexX(:)
    real(kind=KINDDF),device::MinTSteps(:)
    real(kind=KINDDF),value::maxDiffuse
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::scid
    integer::ecid
    integer::bid0
    integer::IC
    integer::JC
    integer::MapedIdex
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::NClusters
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::minDistance
    integer::NNID
    integer::Flag
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	scid = Dev_SEExpdIndexBox(IBox,1)
	ecid = Dev_SEExpdIndexBox(IBox,2)

	NClusters = ecid - scid + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

	MinT = 1.D32
	minDistance = 1.D32

	if (IC .LE. ecid) then

		MapedIdex = SortedIndexX(IC)

        STATUIC = Dev_Clusters(MapedIdex)%m_Statu

        IF(STATUIC .EQ. p_ACTIVEFREE_STATU .or. STATUIC .EQ. p_ACTIVEINGB_STATU) THEN
          Pos_X = Dev_Clusters(MapedIdex)%m_POS(1)
          Pos_Y = Dev_Clusters(MapedIdex)%m_POS(2)
          Pos_Z = Dev_Clusters(MapedIdex)%m_POS(3)

          RADA = Dev_Clusters(MapedIdex)%m_RAD

          DiffA = Dev_Clusters(MapedIdex)%m_DiffCoeff


          !***********Right hand searching**********************
          DO Shift=1,NClusters-1

			JC = IC + Shift
			Flag = (JC .GT. ecid)
			Flag = Flag*Flag
            JC = JC - Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form

                MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
                        exit
				    end if

                end if
        END DO

        !***********Left hand searching**********************
        DO Shift=1,NClusters-1

                JC = IC - Shift
                Flag = (JC .LT. scid)
                Flag = Flag*Flag
                JC = JC + Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form

				MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = 24.D0*DiffA*MinT
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
					  exit
				    end if

                end if

          END DO

          KVOIS(MapedIdex) = 1
		  INDI(MapedIdex,1) = NNID
		  MinTSteps(MapedIdex) = MinT
        end if
	 end if

	 return
  end subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare



!  __global__ void Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen(int BlockNumEachBox, int **IDStartEnd_Dev, double** Dev_ClustersPosXYZ, int* SortedIndexX, int* Dev_NNearestNeighbor) {
!	int tid = threadIdx.y*blockDim.x + threadIdx.x;
!	int bid = blockIdx.y*gridDim.x + blockIdx.x;
!	int cid = bid * BLOCKSIZE + tid;
!	double Pos_X;
!	double Pos_Y;
!	double Pos_Z;
!	int MappedJC;
!	double distance;
!	double minDistance;
!	double distanceX;
!	double distanceY;
!	double distanceZ;
!	int NNID;
!	int MapedIdex;
!	int IBox;
!	int scid;
!	int ecid;
!	int bid0;
!	int IC;
!	int JC;
!	int LeftRemind;
!	int RightRemind;
!	int MaxRemind;
!	bool flagLeftBreak;
!	bool flagRightBreak;
!	flagLeftBreak = false;
!	flagRightBreak = false;
!
!	IBox = bid / BlockNumEachBox;
!
!	scid = IDStartEnd_Dev[IBox][0];
!	ecid = IDStartEnd_Dev[IBox][1];
!
!	bid0 = IBox * BlockNumEachBox;
!
!	IC = scid + (cid - bid0 * BLOCKSIZE);
!
!	minDistance = 1.E32;
!
!	if (IC <= ecid) {
!
!		MapedIdex = SortedIndexX[IC];
!
!		Pos_X = Dev_ClustersPosXYZ[MapedIdex][0];
!		Pos_Y = Dev_ClustersPosXYZ[MapedIdex][1];
!		Pos_Z = Dev_ClustersPosXYZ[MapedIdex][2];
!
!		LeftRemind = IC - scid;
!		RightRemind = ecid - IC;
!
!		MaxRemind = RightRemind;
!		if (LeftRemind > MaxRemind) MaxRemind = LeftRemind;
!
!		for (int Shift = 1; Shift <= MaxRemind; Shift++) {
!
!			/*Right Hand Searching*/
!			if (Shift <= RightRemind && false == flagRightBreak) {
!				JC = IC + Shift;
!
!				MappedJC = SortedIndexX[JC];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJC;
!				}
!
!				if (distanceX > minDistance) {
!					flagRightBreak = true;
!
!					if (true == flagLeftBreak) {
!						break;
!					}
!				}
!			}
!
!			/*Left Hand Searching*/
!			if (Shift <= LeftRemind && false == flagLeftBreak) {
!				JC = IC - Shift;
!
!				MappedJC = SortedIndexX[JC];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJC][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJC][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJC][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJC;
!				}
!
!				if (distanceX > minDistance) {
!					flagLeftBreak = true;
!
!					if (true == flagRightBreak) {
!						break;
!					}
!				}
!			}
!
!		}
!
!		Dev_NNearestNeighbor[MapedIdex] = NNID;
!	}
!}

  attributes(global) subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen(Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,SortedIndexX,MinTSteps,maxDiffuse)
    implicit none
    !--Dummy Vars---
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    integer,device::SortedIndexX(:)
    real(kind=KINDDF),device::MinTSteps(:)
    real(kind=KINDDF),value::maxDiffuse
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::scid
    integer::ecid
    integer::bid0
    integer::IC
    integer::JC
    integer::MapedIdex
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::NClusters
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::minDistance
    logical::flagRightBreak,flagLeftBreak
    integer::NNID
    integer::Flag
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	scid = Dev_SEExpdIndexBox(IBox,1)
	ecid = Dev_SEExpdIndexBox(IBox,2)

	NClusters = ecid - scid + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

	MinT = 1.D32
	minDistance = 1.D32

	flagRightBreak = .false.
	flagLeftBreak = .false.

	if (IC .LE. ecid) then

		MapedIdex = SortedIndexX(IC)

        STATUIC = Dev_Clusters(MapedIdex)%m_Statu

        IF(STATUIC .EQ. p_ACTIVEFREE_STATU .or. STATUIC .EQ. p_ACTIVEINGB_STATU) THEN
          Pos_X = Dev_Clusters(MapedIdex)%m_POS(1)
          Pos_Y = Dev_Clusters(MapedIdex)%m_POS(2)
          Pos_Z = Dev_Clusters(MapedIdex)%m_POS(3)

          RADA = Dev_Clusters(MapedIdex)%m_RAD

          DiffA = Dev_Clusters(MapedIdex)%m_DiffCoeff

          DO Shift=1,NClusters-1

			!***********Right hand searching**********************
			JC = IC + Shift
			Flag = (JC .GT. ecid)
			Flag = Flag*Flag
            JC = JC - Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form
			if (.false. .eq. flagRightBreak .AND. JC .LE. ecid) then

				MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
					  flagRightBreak = .true.

					  if (.true. .eq. flagLeftBreak) then
						  exit
                      end if
				    end if

                end if

            end if

            !***********Left hand searching**********************
			JC = IC - Shift
			Flag = (JC .LT. scid)
			Flag = Flag*Flag
            JC = JC + Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form
			if (.false. .eq. flagLeftBreak .AND. JC .GE. scid) then

				MappedJC = SortedIndexX(JC)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = 24.D0*DiffA*MinT
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
					  flagLeftBreak = .true.

					  if (.true. .eq. flagRightBreak) then
						  exit
                      end if
				    end if

                end if

            end if

          END DO

          KVOIS(MapedIdex) = 1
		  INDI(MapedIdex,1) = NNID
		  MinTSteps(MapedIdex) = MinT
        end if
	 end if

	 return
  end subroutine Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen


!  void My_NeighborListCal_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(int NClusters, int NBox, int **IDStartEnd_Host, &
!                                                                                   int **IDStartEnd_Dev, double* ToSortDev_ClustersPosX,
!                                                                                   double** Dev_ClustersPosXYZ, int* SortedIndexX, int* ReverseMap_SortedIndexX,  int* Host_NNearestNeighbor, float &timerMyMethod) {
!	dim3 threads;
!	dim3 blocks;
!	int NB;
!	cudaError err;
!	int noone;
!	int BlockNumEachBox;
!	int BlockNumEachBoxtemp;
!	int* Dev_NNearestNeighbor;
!
!	cudaMalloc((void**)&Dev_NNearestNeighbor, NClusters * sizeof(int));
!
!	SimpleSort_multipleBox(NClusters, NBox, IDStartEnd_Host, ToSortDev_ClustersPosX, SortedIndexX, ReverseMap_SortedIndexX);
!
!	cudaEvent_t StartEvent;
!	cudaEvent_t StopEvent;
!
!	BlockNumEachBox = 0;
!
!	for (int i = 0; i < NBox; i++) {
!		BlockNumEachBoxtemp = (IDStartEnd_Host[i][1] - IDStartEnd_Host[i][0]) / BLOCKSIZE + 1;
!
!		if (BlockNumEachBox < BlockNumEachBoxtemp) BlockNumEachBox = BlockNumEachBoxtemp;
!	}
!
!	NB = BlockNumEachBox * NBox;
!
!	blocks = dim3(NB, 1, 1);
!	threads = dim3(BLOCKSIZE, 1, 1);
!
!	cudaDeviceSynchronize();
!
!	cudaEventCreate(&StartEvent);
!	cudaEventCreate(&StopEvent);
!
!	cudaEventRecord(StartEvent, 0);
!
!	Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<< < blocks, threads >> > (BlockNumEachBox, IDStartEnd_Dev, Dev_ClustersPosXYZ, SortedIndexX, Dev_NNearestNeighbor);
!
!	cudaDeviceSynchronize();
!
!	cudaEventRecord(StopEvent, 0);
!
!	cudaEventSynchronize(StopEvent);
!
!	cudaEventElapsedTime(&timerMyMethod, StartEvent, StopEvent);
!
!	cudaMemcpy(Host_NNearestNeighbor, Dev_NNearestNeighbor, NClusters * sizeof(int), cudaMemcpyDeviceToHost);
!
!	cudaEventDestroy(StartEvent);
!	cudaEventDestroy(StopEvent);
!}


  subroutine Host_CheckSort_Test(MulitBox,MaxSegmentsNumberEachBox,IDSEArray_ForSort,DevClusters,Dev_IDSEArray,SortedIndex_Dev)
    implicit none
    !---Dummy Vars---
    integer::MulitBox
    integer::MaxSegmentsNumberEachBox
    integer,dimension(:,:),allocatable::IDSEArray_ForSort
    type(ACluster),device,dimension(:),allocatable::DevClusters
    integer,device,dimension(:,:),allocatable::Dev_IDSEArray
    integer,device,dimension(:),allocatable::SortedIndex_Dev
    !---Local Vars---
    type(ACluster),dimension(:),allocatable::HostClusters
    integer,dimension(:,:),allocatable::Host_IDSEArray
    integer::NSize
    integer::IBox
    integer::ICFrom
    integer::ICTo
    type(ACluster)::tempCluster
    integer::temp
    integer::IC,JC
    integer,dimension(:),allocatable::Host_MySortedIndexArray
    integer,dimension(:),allocatable::Host_OutSortedIndexArray
    integer::ISegment
    !---Body---
    NSize = size(DevClusters)

    call AllocateArray_Host(HostClusters,NSize,"HostClusters")
    HostClusters = DevClusters

    call AllocateArray_Host(Host_IDSEArray,MulitBox,2,"Host_IDSEArray")

    Host_IDSEArray = Dev_IDSEArray

    call AllocateArray_Host(Host_OutSortedIndexArray,NSize,"Host_OutSortedIndexArray")

    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)


        DO IC = ICFrom,ICTo
            Host_OutSortedIndexArray(IC) = IC
        END DO

        DO IC = ICFrom,ICTo
            DO JC=IC,ICTo

                if(HostClusters(Host_OutSortedIndexArray(IC))%m_POS(1) .GT. HostClusters(Host_OutSortedIndexArray(JC))%m_POS(1)) then
                    temp = Host_OutSortedIndexArray(IC)
                    Host_OutSortedIndexArray(IC) = Host_OutSortedIndexArray(JC)
                    Host_OutSortedIndexArray(JC) = temp
                end if

            END DO

        END DO
    END DO


    call AllocateArray_Host(Host_MySortedIndexArray,NSize,"Host_MySortedIndexArray")
    Host_MySortedIndexArray = SortedIndex_Dev

    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)
        write(*,*) "******************IBox********************",IBox

        DO IC = ICFrom,ICTo

            if(Host_MySortedIndexArray(IC) .ne. Host_OutSortedIndexArray(IC)) then
                write(*,*) "It is wrong for index: ",IC
                write(*,*) Host_MySortedIndexArray(IC),Host_OutSortedIndexArray(IC)


                write(*,*) "******************My sort method******************"
                DO ISegment = (IBox - 1)*MaxSegmentsNumberEachBox +1,IBox*MaxSegmentsNumberEachBox
                    write(*,*) "ISegment",ISegment,IDSEArray_ForSort(ISegment,1),IDSEArray_ForSort(ISegment,2)
                END DO
                DO JC = ICFrom,ICTo
                    write(*,*) JC,Host_MySortedIndexArray(JC),HostClusters(Host_MySortedIndexArray(JC))%m_POS(1)
                END DO

                write(*,*) "******************CPU sort method******************"
                DO JC = ICFrom,ICTo
                    write(*,*) JC,Host_OutSortedIndexArray(JC),HostClusters(Host_OutSortedIndexArray(JC))%m_POS(1)
                END DO

                pause
            end if

        END DO
    END DO

    return
  end subroutine

  !******************************************************************
  subroutine CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    type(ACluster),dimension(:),allocatable::HostClusters
    integer,dimension(:,:),allocatable::Host_IDSEArray
    integer::NSize
    integer::IBox
    integer::ICFrom
    integer::ICTo
    integer::temp
    integer::IC,JC
    integer,dimension(:),allocatable::Host_KVOIS_MyMethod
    integer,dimension(:),allocatable::Host_KVOIS_BeforeMethod
    integer,dimension(:,:),allocatable::Host_INDI_MyMethod
    integer,dimension(:,:),allocatable::Host_INDI_BeforeMethod
    real(kind=KINDDF),dimension(:),allocatable::Host_MinTSteps_MyMethod
    real(kind=KINDDF),dimension(:),allocatable::Host_MinTSteps_BeforeMethod
    integer::MulitBox
    real(kind=KINDDF)::Distance
    real(kind=KINDDF)::reactTime
    !---Body---
    MulitBox = Host_SimuCtrlParam%MultiBox

    NSize = size(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    call AllocateArray_Host(HostClusters,NSize,"HostClusters")
    HostClusters = Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters

    call AllocateArray_Host(Host_IDSEArray,MulitBox,2,"Host_IDSEArray")

    Host_IDSEArray = Dev_Boxes%dm_SEExpdIndexBox

    call AllocateArray_Host(Host_KVOIS_MyMethod,NSize,"Host_KVOIS_MyMethod")
    Host_KVOIS_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS

    call AllocateArray_Host(Host_INDI_MyMethod,NSize,1,"Host_INDI_MyMethod")
    Host_INDI_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI

    call AllocateArray_Host(Host_MinTSteps_MyMethod,NSize,"Host_MinTSteps_MyMethod")
    Host_MinTSteps_MyMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps


    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    call AllocateArray_Host(Host_KVOIS_BeforeMethod,NSize,"Host_KVOIS_BeforeMethod")
    Host_KVOIS_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS

    call AllocateArray_Host(Host_INDI_BeforeMethod,NSize,1,"Host_INDI_BeforeMethod")
    Host_INDI_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI

    call AllocateArray_Host(Host_MinTSteps_BeforeMethod,NSize,"Host_MinTSteps_BeforeMethod")
    Host_MinTSteps_BeforeMethod = Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps



    DO IBox = 1,MulitBox
        ICFrom = Host_IDSEArray(IBox,1)
        ICTo = Host_IDSEArray(IBox,2)

        DO IC = ICFrom,ICTo
            if(HostClusters(IC)%m_Statu .eq. p_ACTIVEFREE_STATU .or. HostClusters(IC)%m_Statu .eq. p_ACTIVEINGB_STATU) then
              if(Host_INDI_BeforeMethod(IC,1) .ne. Host_INDI_MyMethod(IC,1)) then


                Distance = (HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(1))*(HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(1)) + &
                           (HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(2))*(HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(2)) + &
                           (HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(3))*(HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_POS(3))

                Distance = DSQRT(Distance) - HostClusters(IC)%m_RAD - HostClusters(Host_INDI_BeforeMethod(IC,1))%m_RAD

                if(Distance .GT. 0) then

                    write(*,*) "******************IBox********************",IBox

                    write(*,*) "The neighbor is not true for index: ",IC,Host_INDI_BeforeMethod(IC,1),Host_INDI_MyMethod(IC,1)



                    reactTime = (Distance*Distance)*(1.D0/6.D0)/(HostClusters(IC)%m_DiffCoeff + HostClusters(Host_INDI_BeforeMethod(IC,1))%m_DiffCoeff + 2*SQRT(HostClusters(IC)%m_DiffCoeff*HostClusters(Host_INDI_BeforeMethod(IC,1))%m_DiffCoeff ))
                    write(*,*) "Distance Before method",Distance,"reaction time",reactTime


                    Distance = (HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(1))*(HostClusters(IC)%m_POS(1) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(1)) + &
                            (HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(2))*(HostClusters(IC)%m_POS(2) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(2)) + &
                            (HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(3))*(HostClusters(IC)%m_POS(3) - HostClusters(Host_INDI_MyMethod(IC,1))%m_POS(3))


                    Distance = DSQRT(Distance) - HostClusters(IC)%m_RAD - HostClusters(Host_INDI_MyMethod(IC,1))%m_RAD
                    reactTime = (Distance*Distance)*(1.D0/6.D0)/(HostClusters(IC)%m_DiffCoeff + HostClusters(Host_INDI_MyMethod(IC,1))%m_DiffCoeff + 2*SQRT(HostClusters(IC)%m_DiffCoeff*HostClusters(Host_INDI_MyMethod(IC,1))%m_DiffCoeff ))
                    write(*,*) "Distance my method",Distance,"reaction time",reactTime

                    write(*,*) Host_MinTSteps_BeforeMethod(IC),Host_MinTSteps_MyMethod(IC)
                    pause
                end if
              end if
            end if

        END DO
    END DO

    call DeAllocateArray_Host(HostClusters,"HostClusters")
    call DeAllocateArray_Host(Host_IDSEArray,"Host_IDSEArray")
    call DeAllocateArray_Host(Host_KVOIS_MyMethod,"Host_KVOIS_MyMethod")
    call DeAllocateArray_Host(Host_KVOIS_BeforeMethod,"Host_KVOIS_BeforeMethod")
    call DeAllocateArray_Host(Host_INDI_MyMethod,"Host_INDI_MyMethod")
    call DeAllocateArray_Host(Host_INDI_BeforeMethod,"Host_INDI_BeforeMethod")
    call DeAllocateArray_Host(Host_MinTSteps_MyMethod,"Host_MinTSteps_MyMethod")
    call DeAllocateArray_Host(Host_MinTSteps_BeforeMethod,"Host_MinTSteps_BeforeMethod")
    return
  end subroutine


!  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
!	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
!    !     INPUT:  Host_Boxes               , boxes information in host
!    !             Host_SimuCtrlParam
!    !             Dev_Boxes                , boxes information in device
!    implicit none
!    !---Dummy Vars---
!    type(SimulationBoxes), intent(in)::Host_Boxes
!    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
!    type(SimulationBoxes_GPU)::Dev_Boxes
!    real(kind=KINDDF),intent(in)::MaxDiffuse
!    !---Local Vars---
!    integer::MULTIBOX
!    type(dim3)::blocks
!    type(dim3)::threads
!    integer::NB, NBX, NBY, BX, BY
!    integer::BlockNumEachBox
!    logical::ChangedToUsedIndex
!    type(cudaEvent)::StartEventSort
!    type(cudaEvent)::StopEventSort
!    type(cudaEvent)::StartEventNeighborCal
!    type(cudaEvent)::StopEventNeighborCal
!    integer::IState
!    real::timeSort
!    real::timeNeighborCal
!    !---Body---
!    #ifdef MC_PROFILING
!    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
!    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
!    #endif
!    !---Body---
!
!    IState = cudaEventCreate(StartEventSort)
!    IState = cudaEventCreate(StopEventSort)
!    IState = cudaEventCreate(StartEventNeighborCal)
!    IState = cudaEventCreate(StopEventNeighborCal)
!
!    MULTIBOX = Host_SimuCtrlParam%MultiBox
!
!    ChangedToUsedIndex = .false.
!
!    !*** to determine the block size
!    BX = p_BLOCKSIZE_MyMethod
!    BY = 1
!    !*** to determine the dimension of blocks
!    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
!       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
!        ChangedToUsedIndex = .false.
!        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
!    else
!        ChangedToUsedIndex = .true.
!        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
!    end if
!    NB = BlockNumEachBox*MultiBox
!
!    blocks  = dim3(NB, 1, 1)
!    threads = dim3(BX, BY, 1)
!
!    IState = cudaEventRecord(StartEventSort,0)
!
!    call Dev_Boxes%dm_BitionicSort%SortX(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)
!
!    IState = cudaEventRecord(StopEventSort,0)
!
!    IState = cudaEventSynchronize(StopEventSort)
!
!    IState = cudaEventElapsedTime(timeSort,StartEventSort,StopEventSort)
!
!    write(*,*) "Sort time is: ",timeSort
!
!    IState = cudaThreadSynchronize()
!
!    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)
!
!    IState = cudaEventRecord(StartEventNeighborCal,0)
!
!    if(ChangedToUsedIndex .eq. .false.) then
!        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
!                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
!                                                                                                   BlockNumEachBox,                               &
!                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
!                                                                                                   MaxDiffuse)
!    else
!        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
!                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
!                                                                                                   BlockNumEachBox,                               &
!                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
!                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
!                                                                                                   MaxDiffuse)
!
!    end if
!
!    IState = cudaEventRecord(StopEventNeighborCal,0)
!
!    IState = cudaEventSynchronize(StopEventNeighborCal)
!
!    IState = cudaEventElapsedTime(timeNeighborCal,StartEventNeighborCal,StopEventNeighborCal)
!
!    write(*,*) "NeighborCal time is for my Method noShared_LeftRightCohen : ",timeNeighborCal
!
!
!    IState = cudaEventDestroy(StartEventSort)
!    IState = cudaEventDestroy(StopEventSort)
!    IState = cudaEventDestroy(StartEventNeighborCal)
!    IState = cudaEventDestroy(StopEventNeighborCal)
!
!    IState = cudaThreadSynchronize()
!
!    !call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
!    call Cal_Neighbore_Table_GPU_TimeNearest_WithOutActiveIndex(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
!
!    IState = cudaThreadSynchronize()
!
!    call Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
!
!    IState = cudaThreadSynchronize()
!
!    call Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortXY_multipleBox_noShared(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
!
!    IState = cudaThreadSynchronize()
!
!    call Cal_Neighbore_Table_GPU_Nearest_LC(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
!
!    IState = cudaThreadSynchronize()
!
!    call Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen_Sweepout(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
!
!    IState = cudaThreadSynchronize()
!
!
!    return
!  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen


  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    call Dev_Boxes%dm_BitionicSort%SortX(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    else
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)

    end if


    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen





  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen_Sweepout(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    type(cudaEvent)::StartEventSort
    type(cudaEvent)::StopEventSort
    type(cudaEvent)::StartEventNeighborCal
    type(cudaEvent)::StopEventNeighborCal
    integer::IState
    real::timeSort
    real::timeNeighborCal
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    if(TheFlag .LE. 0) then

        call Dev_Boxes%SweepUnActiveMemory_GPUToCPU(Host_Boxes,Host_SimuCtrlParam)
    end if

    TheFlag = TheFlag + 1

    IState = cudaEventCreate(StartEventSort)
    IState = cudaEventCreate(StopEventSort)
    IState = cudaEventCreate(StartEventNeighborCal)
    IState = cudaEventCreate(StopEventNeighborCal)

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    IState = cudaEventRecord(StartEventSort,0)

    call Dev_Boxes%dm_BitionicSort%SortX(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    IState = cudaEventRecord(StopEventSort,0)

    IState = cudaEventSynchronize(StopEventSort)

    IState = cudaEventElapsedTime(timeSort,StartEventSort,StopEventSort)

    write(*,*) "Sort time is: ",timeSort

    IState = cudaThreadSynchronize()

    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)

    IState = cudaEventRecord(StartEventNeighborCal,0)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    else
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare_LeftRightCohen<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)

    end if

    IState = cudaEventRecord(StopEventNeighborCal,0)

    IState = cudaEventSynchronize(StopEventNeighborCal)

    IState = cudaEventElapsedTime(timeNeighborCal,StartEventNeighborCal,StopEventNeighborCal)

    write(*,*) "NeighborCal time is for my Method noShared_LeftRightCohen sweep out: ",timeNeighborCal


    IState = cudaEventDestroy(StartEventSort)
    IState = cudaEventDestroy(StopEventSort)
    IState = cudaEventDestroy(StartEventNeighborCal)
    IState = cudaEventDestroy(StopEventNeighborCal)

    IState = cudaThreadSynchronize()

    !call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared_LeftRightCohen_Sweepout








  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    type(cudaEvent)::StartEventSort
    type(cudaEvent)::StopEventSort
    type(cudaEvent)::StartEventNeighborCal
    type(cudaEvent)::StopEventNeighborCal
    integer::IState
    real::timeSort
    real::timeNeighborCal
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    IState = cudaEventCreate(StartEventSort)
    IState = cudaEventCreate(StopEventSort)
    IState = cudaEventCreate(StartEventNeighborCal)
    IState = cudaEventCreate(StopEventNeighborCal)

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    IState = cudaEventRecord(StartEventSort,0)

    call Dev_Boxes%dm_BitionicSort%SortX(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    IState = cudaEventRecord(StopEventSort,0)

    IState = cudaEventSynchronize(StopEventSort)

    IState = cudaEventElapsedTime(timeSort,StartEventSort,StopEventSort)

    write(*,*) "Sort time is: ",timeSort

    IState = cudaThreadSynchronize()

    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)

    IState = cudaEventRecord(StartEventNeighborCal,0)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    else
        call Kernel_MyNeighborListCal_SortX_multipleBox_noshare<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)

    end if

    IState = cudaEventRecord(StopEventNeighborCal,0)

    IState = cudaEventSynchronize(StopEventNeighborCal)

    IState = cudaEventElapsedTime(timeNeighborCal,StartEventNeighborCal,StopEventNeighborCal)

    write(*,*) "NeighborCal time is for my Method noShared: ",timeNeighborCal



    IState = cudaEventDestroy(StartEventSort)
    IState = cudaEventDestroy(StopEventSort)
    IState = cudaEventDestroy(StartEventNeighborCal)
    IState = cudaEventDestroy(StopEventNeighborCal)

    !call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    IState = cudaThreadSynchronize()

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortX_multipleBox_noShared


!  __global__ void Kernel_MyNeighborListCal_SortXY_multipleBox_noshare(int BlockNumEachBox, int **IDStartEnd_Dev, double** Dev_ClustersPosXYZ, int* SortedIndexX,  int* SortedIndexY, int* ReverseMap_SortedIndexX, int* ReverseMap_SortedIndexY, int* Dev_NNearestNeighbor) {
!	int tid = threadIdx.y*blockDim.x + threadIdx.x;
!	int bid = blockIdx.y*gridDim.x + blockIdx.x;
!	int cid = bid * BLOCKSIZE + tid;
!	double Pos_X;
!	double Pos_Y;
!	double Pos_Z;
!	int MappedJCX;
!	int MappedJCY;
!	double distance;
!	double minDistance;
!	double distanceX;
!	double distanceY;
!	double distanceZ;
!	int NNID;
!	int MapedIndex;
!	int IBox;
!	int scid;
!	int ecid;
!	int bid0;
!	int ICX;
!	int JCX;
!	int ICY;
!	int JCY;
!	bool XorY;  // true for x, false for y
!
!	IBox = bid / BlockNumEachBox;
!
!	scid = IDStartEnd_Dev[IBox][0];
!	ecid = IDStartEnd_Dev[IBox][1];
!
!	bid0 = IBox * BlockNumEachBox;
!
!	ICX = scid + (cid - bid0 * BLOCKSIZE);
!
!	minDistance = 1.E32;
!
!	XorY = true;
!
!	if (ICX <= ecid) {
!
!		MapedIndex = SortedIndexX[ICX];
!
!		Pos_X = Dev_ClustersPosXYZ[MapedIndex][0];
!		Pos_Y = Dev_ClustersPosXYZ[MapedIndex][1];
!		Pos_Z = Dev_ClustersPosXYZ[MapedIndex][2];
!
!		ICY = ReverseMap_SortedIndexY[MapedIndex];
!
!		/*Right Hand Searching*/
!		for (JCX = ICX + 1; JCX <= ecid; JCX++) {
!
!			MappedJCX = SortedIndexX[JCX];
!
!			distanceX = Dev_ClustersPosXYZ[MappedJCX][0] - Pos_X;
!			distanceY = Dev_ClustersPosXYZ[MappedJCX][1] - Pos_Y;
!			distanceZ = Dev_ClustersPosXYZ[MappedJCX][2] - Pos_Z;
!
!			distanceX = distanceX * distanceX;
!			distanceY = distanceY * distanceY;
!			distanceZ = distanceZ * distanceZ;
!
!			distance = distanceX + distanceY + distanceZ;
!
!			if (minDistance > distance) {
!				minDistance = distance;
!				NNID = MappedJCX;
!			}
!
!			if (distanceX > minDistance) {
!				XorY = true;
!				break;
!			}
!
!			//Y restrict
!			JCY = ICY + JCX - ICX;
!			if (JCY < scid) JCY = scid;
!			if (JCY > ecid) JCY = ecid;
!
!			if (JCY != ICY) {
!
!				MappedJCY = SortedIndexY[JCY];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJCY][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJCY][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJCY][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJCY;
!				}
!
!				if (distanceY > minDistance) {
!					XorY = false;
!					break;
!				}
!			}
!
!		}
!
!
!		/*Left Hand Searching*/
!		if (true == XorY) {
!
!			for (JCX = ICX - 1; JCX >= scid; JCX--) {
!
!				MappedJCX = SortedIndexX[JCX];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJCX][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJCX][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJCX][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJCX;
!				}
!
!				if (distanceX > minDistance) {
!					break;
!				}
!
!			}
!
!		}else{
!
!			for (JCY = ICY - 1; JCY >= scid; JCY--) {
!
!				MappedJCY = SortedIndexY[JCY];
!
!				distanceX = Dev_ClustersPosXYZ[MappedJCY][0] - Pos_X;
!				distanceY = Dev_ClustersPosXYZ[MappedJCY][1] - Pos_Y;
!				distanceZ = Dev_ClustersPosXYZ[MappedJCY][2] - Pos_Z;
!
!				distanceX = distanceX * distanceX;
!				distanceY = distanceY * distanceY;
!				distanceZ = distanceZ * distanceZ;
!
!				distance = distanceX + distanceY + distanceZ;
!
!				if (minDistance > distance) {
!					minDistance = distance;
!					NNID = MappedJCY;
!				}
!
!				if (distanceY > minDistance) {
!					break;
!				}
!
!			}
!
!		}
!
!		Dev_NNearestNeighbor[MapedIndex] = NNID;
!	}
!}


  subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortXY_multipleBox_noShared(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    type(cudaEvent)::StartEventSort
    type(cudaEvent)::StopEventSort
    type(cudaEvent)::StartEventNeighborCal
    type(cudaEvent)::StopEventNeighborCal
    integer::IState
    real::timeSort
    real::timeNeighborCal
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    IState = cudaEventCreate(StartEventSort)
    IState = cudaEventCreate(StopEventSort)
    IState = cudaEventCreate(StartEventNeighborCal)
    IState = cudaEventCreate(StopEventNeighborCal)

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    IState = cudaEventRecord(StartEventSort,0)

    call Dev_Boxes%dm_BitionicSort%SortX(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    call Dev_Boxes%dm_BitionicSort%SortY(MULTIBOX,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    IState = cudaEventRecord(StopEventSort,0)

    IState = cudaEventSynchronize(StopEventSort)

    IState = cudaEventElapsedTime(timeSort,StartEventSort,StopEventSort)

    write(*,*) "Sort time is: ",timeSort

    IState = cudaThreadSynchronize()

    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)

    IState = cudaEventRecord(StartEventNeighborCal,0)

    if(ChangedToUsedIndex .eq. .false.) then
        call Kernel_MyNeighborListCal_SortXY_multipleBox_noshare<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexY_Dev,     &
                                                                                                   Dev_Boxes%dm_BitionicSort%ReverseSortedIndexY_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)
    else
        call Kernel_MyNeighborListCal_SortXY_multipleBox_noshare<<<blocks,threads>>>(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                                                   Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                                                   BlockNumEachBox,                               &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexX_Dev,     &
                                                                                                   Dev_Boxes%dm_BitionicSort%SortedIndexY_Dev,     &
                                                                                                   Dev_Boxes%dm_BitionicSort%ReverseSortedIndexY_Dev,     &
                                                                                                   Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                                                   MaxDiffuse)

    end if

    IState = cudaEventRecord(StopEventNeighborCal,0)

    IState = cudaEventSynchronize(StopEventNeighborCal)

    IState = cudaEventElapsedTime(timeNeighborCal,StartEventNeighborCal,StopEventNeighborCal)

    write(*,*) "NeighborCal time is for my Method XY noShared: ",timeNeighborCal


    IState = cudaEventDestroy(StartEventSort)
    IState = cudaEventDestroy(StopEventSort)
    IState = cudaEventDestroy(StartEventNeighborCal)
    IState = cudaEventDestroy(StopEventNeighborCal)

    !call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    return
  end subroutine Cal_Neighbore_Table_GPU_Nearest_ArbitrayBitonicSortXY_multipleBox_noShared



  attributes(global) subroutine Kernel_MyNeighborListCal_SortXY_multipleBox_noshare(Dev_Clusters,Dev_SEExpdIndexBox,KVOIS,INDI,BlockNumEachBox,SortedIndexX,SortedIndexY,ReverseSortedIndexY,MinTSteps,maxDiffuse)
    implicit none
    !--Dummy Vars---
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer,value::BlockNumEachBox
    integer,device::SortedIndexX(:)
    integer,device::SortedIndexY(:)
    integer,device::ReverseSortedIndexY(:)
    real(kind=KINDDF),device::MinTSteps(:)
    real(kind=KINDDF),value::maxDiffuse
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::scid
    integer::ecid
    integer::bid0
    integer::ICX
    integer::ICY
    integer::JCX
    integer::JCY
    integer::MapedIdex
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::NClusters
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::minDistance
    integer::NNID
    integer::Flag
    logical::XorY
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	scid = Dev_SEExpdIndexBox(IBox,1)
	ecid = Dev_SEExpdIndexBox(IBox,2)

	NClusters = ecid - scid + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

	ICX = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

	MinT = 1.D32
	minDistance = 1.D32

	if (ICX .LE. ecid) then

		MapedIdex = SortedIndexX(ICX)

        STATUIC = Dev_Clusters(MapedIdex)%m_Statu

        IF(STATUIC .EQ. p_ACTIVEFREE_STATU .or. STATUIC .EQ. p_ACTIVEINGB_STATU) THEN
          Pos_X = Dev_Clusters(MapedIdex)%m_POS(1)
          Pos_Y = Dev_Clusters(MapedIdex)%m_POS(2)
          Pos_Z = Dev_Clusters(MapedIdex)%m_POS(3)

          RADA = Dev_Clusters(MapedIdex)%m_RAD

          DiffA = Dev_Clusters(MapedIdex)%m_DiffCoeff

          ICY = ReverseSortedIndexY(MapedIdex)
          !***********Right hand searching**********************
          DO Shift=1,NClusters-1

                JCX = ICX + Shift
                Flag = (JCX .GT. ecid)
                Flag = Flag*Flag
                JCX = JCX - Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form

                MappedJC = SortedIndexX(JCX)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
                        XorY = .true.
                        exit
				    end if

                end if

                ! Y restrict
                JCY = ICY + Shift
                Flag = (JCY .GT. ecid)
                Flag = Flag*Flag
                JCY = JCY - Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form

                MappedJC = SortedIndexY(JCY)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_y .GT. minDistance*minDistance) then
                        XorY = .false.
                        exit
				    end if

                end if
        END DO

        !***********Left hand searching**********************
        if(XorY .eq. .true.) then

          DO Shift=1,NClusters-1

                JCX = ICX - Shift
                Flag = (JCX .LT. scid)
                Flag = Flag*Flag
                JCX = JCX + Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form

                MappedJC = SortedIndexX(JCX)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_x .GT. minDistance*minDistance) then
                        exit
				    end if

                end if
          END DO

        else

            DO Shift=1,NClusters-1

                ! Y restrict
                JCY = ICY - Shift
                Flag = (JCY .LT. scid)
                Flag = Flag*Flag
                JCY = JCY + Flag*dm_PERIOD(1)*NClusters  ! in PGI compiler the .true. is -1 in integer form,false is 0 in integer form
                MappedJC = SortedIndexY(JCY)

				STATUJC = Dev_Clusters(MappedJC)%m_Statu

				if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                    SEP_x = SEP_x*SEP_x

                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                    SEP_y = SEP_y*SEP_y

                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                    SEP_z = SEP_z*SEP_z

                    DIST2 = SEP_x + SEP_y + SEP_z

                    RADB = Dev_Clusters(MappedJC)%m_RAD

                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                    if(reactTime .LE. MinT ) then
                      MinT = reactTime
                      NNID = MappedJC
                      !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                      !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                      minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                    end if

				    if (SEP_y .GT. minDistance*minDistance) then
                        exit
				    end if

                end if
            END DO

          end if

          KVOIS(MapedIdex) = 1
		  INDI(MapedIdex,1) = NNID
		  MinTSteps(MapedIdex) = MinT
        end if
	 end if

	 return
  end subroutine Kernel_MyNeighborListCal_SortXY_multipleBox_noshare



















  !*************************************************************************************
  subroutine Cal_Neighbore_Table_GPU_Nearest_LC(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes,MaxDiffuse)
    	    !***  PURPOSE:  to update the neighbore list of atoms (GPU version ,NNearest , MultiBox)
    !     INPUT:  Host_Boxes               , boxes information in host
    !             Host_SimuCtrlParam
    !             Dev_Boxes                , boxes information in device
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    real(kind=KINDDF),intent(in)::MaxDiffuse
    !---Local Vars---
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    type(cudaEvent)::StartEventSort
    type(cudaEvent)::StopEventSort
    type(cudaEvent)::StartEventNeighborCal
    type(cudaEvent)::StopEventNeighborCal
    integer::IState
    real::timeSort
    real::timeNeighborCal
    integer::CellsNumOneDim
    !---Body---
    #ifdef MC_PROFILING
    call Time_Start(T_Cal_Neighbore_Table_GPU_Nearest_Start)
    N_Invoke_Cal_Neighbor_GPU = N_Invoke_Cal_Neighbor_GPU + 1
    #endif
    !---Body---

    CellsNumOneDim = 10

    IState = cudaEventCreate(StartEventSort)
    IState = cudaEventCreate(StopEventSort)
    IState = cudaEventCreate(StartEventNeighborCal)
    IState = cudaEventCreate(StopEventNeighborCal)

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    IState = cudaEventRecord(StartEventSort,0)

    if(ChangedToUsedIndex .eq. .false.) then
        call ConstructMappedArray_LC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                         Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                         Dev_Boxes%dm_BitionicSort%SortedCellIndex_Dev, &
                                                         Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                         CellsNumOneDim)
    else
        call ConstructMappedArray_LC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                         Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                         Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                         Dev_Boxes%dm_BitionicSort%SortedCellIndex_Dev, &
                                                         Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                         CellsNumOneDim)

    end if


    call Dev_Boxes%dm_BitionicSort%SortCellID()

    call PrefixSumCellID(MULTIBOX,Dev_Boxes%dm_BitionicSort%SortedCellIndex_Dev,Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev,CellsNumOneDim)

    IState = cudaEventRecord(StopEventSort,0)

    IState = cudaEventSynchronize(StopEventSort)

    IState = cudaEventElapsedTime(timeSort,StartEventSort,StopEventSort)

    write(*,*) "construct Sort and prefix-sum time is: ",timeSort


    call CheckLC(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)



    IState = cudaThreadSynchronize()

    !call Host_CheckSort_Test(MULTIBOX,Dev_Boxes%dm_BitionicSort%MaxSegmentsNumEachBox,Dev_Boxes%dm_BitionicSort%IDStartEnd_ForSort_Host,Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,Dev_Boxes%dm_SEExpdIndexBox,Dev_Boxes%dm_BitionicSort%SortedIndex_Dev)

    IState = cudaEventRecord(StartEventNeighborCal,0)

    if(ChangedToUsedIndex .eq. .false.) then

        call Kernel_Neighbore_Table_GPU_Nearest_LC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                       Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                       dm_SEIndex_ForCell,                            &
                                                                       Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                                       CellsNumOneDim,                                &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                       MaxDiffuse)

    else
        call Kernel_Neighbore_Table_GPU_Nearest_LC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                                       Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_KVOIS,         &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_INDI,          &
                                                                       dm_SEIndex_ForCell,                            &
                                                                       Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                                       CellsNumOneDim,                                &
                                                                       Dev_Boxes%dm_ClusterInfo_GPU%dm_MinTSteps,     &
                                                                       MaxDiffuse)

    end if

    IState = cudaEventRecord(StopEventNeighborCal,0)

    IState = cudaEventSynchronize(StopEventNeighborCal)

    IState = cudaEventElapsedTime(timeNeighborCal,StartEventNeighborCal,StopEventNeighborCal)

    write(*,*) "NeighborCal time is for linked Cell method: ",timeNeighborCal



    IState = cudaEventDestroy(StartEventSort)
    IState = cudaEventDestroy(StopEventSort)
    IState = cudaEventDestroy(StartEventNeighborCal)
    IState = cudaEventDestroy(StopEventNeighborCal)

    call CheckNeighborList(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)

    IState = cudaThreadSynchronize()

!    pause

  end subroutine Cal_Neighbore_Table_GPU_Nearest_LC

  !************************************************************************************
  attributes(global) subroutine ConstructMappedArray_LC(BlockNumEachBox,              &
                                                        Dev_Clusters,                 &
                                                        Dev_SEExpdIndexBox_ForBox,    &
                                                        SortedCellIndex_Dev,          &
                                                        SortedIndex_ForCell_Dev,      &
                                                        CellsNumOneDim)
    implicit none
    !--Dummy Vars---
    integer,value::BlockNumEachBox
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox_ForBox(:,:)
    integer,device::SortedCellIndex_Dev(:)
    integer,device::SortedIndex_ForCell_Dev(:)
    integer,value::CellsNumOneDim
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::bid0
    integer::IC
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z
    integer::scid,ecid
    integer::IXCell,IYCell,IZCell
    integer::IDCell
    integer::ICellStart
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

    scid = Dev_SEExpdIndexBox_ForBox(IBox,1)
	ecid = Dev_SEExpdIndexBox_ForBox(IBox,2)

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

    ICellStart = (IBox-1)*(CellsNumOneDim**3) + 1

	if (IC .LE. ecid) then
        Pos_X = Dev_Clusters(IC)%m_POS(1)
        Pos_Y = Dev_Clusters(IC)%m_POS(2)
        Pos_Z = Dev_Clusters(IC)%m_POS(3)

        IXCell = int((Pos_X - dm_BOXBOUNDARY(1,1))/(dm_BOXSIZE(1)/CellsNumOneDim))
        IXCell = min(IXCell,CellsNumOneDim-1)
        IYCell = int((Pos_Y - dm_BOXBOUNDARY(2,1))/(dm_BOXSIZE(2)/CellsNumOneDim))
        IYCell = min(IYCell,CellsNumOneDim-1)
        IZCell = int((Pos_Z - dm_BOXBOUNDARY(3,1))/(dm_BOXSIZE(3)/CellsNumOneDim))
        IZCell = min(IZCell,CellsNumOneDim-1)

        IDCell = ICellStart + IZCell*CellsNumOneDim*CellsNumOneDim + IYCell*CellsNumOneDim + IXCell

        SortedCellIndex_Dev(IC) = IDCell

        SortedIndex_ForCell_Dev(IC) = IC
    end if

    return
  end subroutine ConstructMappedArray_LC

  !************************************************************************************
  subroutine PrefixSumCellID(NBox,SortedCellIndex_Dev,SortedIndex_ForCell_Dev,CellsNumOneDim)
    implicit none
    !---Dummy Vars---
    integer::NBox
    integer,device::SortedCellIndex_Dev(:)
    integer,device::SortedIndex_ForCell_Dev(:)
    integer,value::CellsNumOneDim
    !---Local Vars---
    integer,dimension(:),allocatable::Host_SortedCellIndex
    integer::NSize
    integer::ICell
    integer::TotalCellsNum
    integer::IC
    integer::CurrentCell
    !---Body---
    TotalCellsNum = NBox*(CellsNumOneDim**3)

    NSize = size(SortedCellIndex_Dev)
    call AllocateArray_Host(Host_SortedCellIndex,NSize,"Host_SortedCellIndex")

    Host_SortedCellIndex = SortedCellIndex_Dev


    call DeAllocateArray_GPU(dm_SEIndex_ForCell,"dm_SEIndex_ForCell")
    call AllocateArray_GPU(dm_SEIndex_ForCell,TotalCellsNum,2,"dm_SEIndex_ForCell")
    call DeAllocateArray_Host(m_SEIndex_ForCell,"m_SEIndex_ForCell")
    call AllocateArray_Host(m_SEIndex_ForCell,TotalCellsNum,2,"m_SEIndex_ForCell")


    DO ICell = 1,TotalCellsNum
        m_SEIndex_ForCell(ICell,1) = 0
        m_SEIndex_ForCell(ICell,2) = -1
    END DO

    CurrentCell = Host_SortedCellIndex(1)
    m_SEIndex_ForCell(CurrentCell,1) = 1
    DO IC = 2,NSize
        if(Host_SortedCellIndex(IC) .GT. CurrentCell) then
            m_SEIndex_ForCell(CurrentCell,2) = IC - 1


            CurrentCell = Host_SortedCellIndex(IC)

            m_SEIndex_ForCell(CurrentCell,1) = IC
        end if

    END DO
    m_SEIndex_ForCell(CurrentCell,2) = NSize


    dm_SEIndex_ForCell = m_SEIndex_ForCell

    call DeAllocateArray_Host(Host_SortedCellIndex,"Host_SortedCellIndex")

    return
  end subroutine PrefixSumCellID

!  !************************************************************************************
!  attributes(global) subroutine Kernel_PrefixSumCellID(BlockNumEachBox,              &
!                                                       Dev_SEExpdIndexBox_ForBox,    &
!                                                       Dev_SEExpdIndexBox_ForCell,   &
!                                                       Dev_MappedArray,              &
!                                                       CellsNumOneDim)
!    implicit none
!    !--Dummy Vars---
!    integer,value::BlockNumEachBox
!    integer, device::Dev_SEExpdIndexBox_ForBox(:,:)
!    integer, device::Dev_SEExpdIndexBox_ForCell(:,:)
!    integer,device::Dev_MappedArray(:)
!    integer,value::CellsNumOneDim
!    !---Local Vars---
!    integer::IBox
!    integer::tid
!    integer::bid
!    integer::cid
!    integer::bid0
!    integer::IC
!    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z
!    integer::scid,ecid
!    integer::IXCell,IYCell,IZCell
!    integer::IDCell
!    !---Body---
!    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
!    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
!    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block
!
!	IBox = (bid-1)/BlockNumEachBox + 1
!
!	bid0 = (IBox-1)*BlockNumEachBox + 1
!
!    scid = Dev_SEExpdIndexBox_ForBox(IBox,1)
!	ecid = Dev_SEExpdIndexBox_ForBox(IBox,2)
!
!	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)
!
!    return
!  end subroutine Kernel_PrefixSumCellID

  subroutine CheckLC(Host_Boxes,Host_SimuCtrlParam,Dev_Boxes)
    implicit none
    !---Dummy Vars---
    type(SimulationBoxes), intent(in)::Host_Boxes
    type(SimulationCtrlParam),intent(in)::Host_SimuCtrlParam
    type(SimulationBoxes_GPU)::Dev_Boxes
    !---Local Vars---
    integer::IBox
    integer::MULTIBOX
    type(dim3)::blocks
    type(dim3)::threads
    integer::NB, NBX, NBY, BX, BY
    integer::BlockNumEachBox
    logical::ChangedToUsedIndex
    integer::CellsNumOneDim
    integer,dimension(:),allocatable::Finded_Host
    integer,device,dimension(:),allocatable::Finded_Dev
    integer::IC
    integer::JC
    integer::NSize
    type(ACluster),dimension(:),allocatable::HostClusters
    integer::IXCell,IYCell,IZCell,IDCell
    integer::ICellStart
    integer,dimension(:),allocatable::SortedIndex_ForCell_Host
    integer,dimension(:),allocatable::SortedCellIndex_Host
    !---Body---

    CellsNumOneDim = 10

    MULTIBOX = Host_SimuCtrlParam%MultiBox

    ChangedToUsedIndex = .false.

    !*** to determine the block size
    BX = p_BLOCKSIZE_MyMethod
    BY = 1
    !*** to determine the dimension of blocks
    if(maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1)) .GE. &
       maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))) then
        ChangedToUsedIndex = .false.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEExpdIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    else
        ChangedToUsedIndex = .true.
        BlockNumEachBox = maxval(Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,2)-Host_Boxes%m_BoxesInfo%SEUsedIndexBox(:,1))/p_BLOCKSIZE_MyMethod + 1
    end if
    NB = BlockNumEachBox*MultiBox

    blocks  = dim3(NB, 1, 1)
    threads = dim3(BX, BY, 1)

    NSize = size(Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters)

    call AllocateArray_GPU(Finded_Dev,NSize,"Finded_Dev")
    call AllocateArray_Host(Finded_Host,NSize,"Finded_Host")

    if(ChangedToUsedIndex .eq. .false.) then

        call Kernel_CheckLC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                Dev_Boxes%dm_SEExpdIndexBox,                   &
                                                dm_SEIndex_ForCell,                            &
                                                Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                CellsNumOneDim,Finded_Dev)

    else
        call Kernel_CheckLC<<<blocks,threads>>>(BlockNumEachBox,                               &
                                                Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters,      &
                                                Dev_Boxes%dm_SEUsedIndexBox,                   &
                                                dm_SEIndex_ForCell,                            &
                                                Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev, &
                                                CellsNumOneDim,Finded_Dev)

    end if

    Finded_Host = Finded_Dev

    m_SEIndex_ForCell = dm_SEIndex_ForCell

    call AllocateArray_Host(HostClusters,NSize,"HostClusters")
    HostClusters = Dev_Boxes%dm_ClusterInfo_GPU%dm_Clusters

    call AllocateArray_Host(SortedIndex_ForCell_Host,NSize,"SortedIndex_ForCell_Host")
    SortedIndex_ForCell_Host = Dev_Boxes%dm_BitionicSort%SortedIndex_ForCell_Dev

    call AllocateArray_Host(SortedCellIndex_Host,NSize,"SortedCellIndex_Host")
    SortedCellIndex_Host = Dev_Boxes%dm_BitionicSort%SortedCellIndex_Dev


    DO IC = 1,NSize-1
        if(SortedCellIndex_Host(IC) .GT. SortedCellIndex_Host(IC+1)) then
            write(*,*) "It is wrong for index: ",IC
            write(*,*) "SortedCellIndex_Host(IC) ,SortedCellIndex_Host(IC+ 1) ",SortedCellIndex_Host(IC) ,SortedCellIndex_Host(IC+ 1)


            DO IBox = 1,MULTIBOX
                if(IC .GE. Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,1) .AND. IC .LE. Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,2)) then
                    write(*,*) "In Box: ",IBox

                    write(*,*) "SEBox: ",Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,1),Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,2)
                end if

            END DO







            pause
        end if
    END DO

    DO IC = 1,NSize

        if(Finded_Host(IC) .LE. 0) then
            write(*,*) "It is wrong for index to find cell: ",IC,Finded_Host(IC)

            DO IBox = 1,MULTIBOX
                if(IC .GE. Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,1) .AND. IC .LE. Host_Boxes%m_BoxesInfo%SEUsedIndexBox(IBox,2)) then
                    write(*,*) "In Box: ",IBox

                    ICellStart = (IBox-1)*(CellsNumOneDim**3) + 1
                    IXCell = int((HostClusters(IC)%m_POS(1) - Host_Boxes%BOXBOUNDARY(1,1))/(Host_Boxes%BOXSIZE(1)/CellsNumOneDim))
                    IXCell = min(IXCell,CellsNumOneDim-1)
                    IXCell = max(IXCell,0)
                    IYCell = int((HostClusters(IC)%m_POS(2) - Host_Boxes%BOXBOUNDARY(2,1))/(Host_Boxes%BOXSIZE(2)/CellsNumOneDim))
                    IYCell = min(IYCell,CellsNumOneDim-1)
                    IYCell = max(IYCell,0)
                    IZCell = int((HostClusters(IC)%m_POS(3) - Host_Boxes%BOXBOUNDARY(3,1))/(Host_Boxes%BOXSIZE(3)/CellsNumOneDim))
                    IZCell = min(IZCell,CellsNumOneDim-1)
                    IZCell = max(IZCell,0)
                    IDCell = ICellStart + IZCell*CellsNumOneDim*CellsNumOneDim + IYCell*CellsNumOneDim + IXCell
                    write(*,*) "IDCell ",IDCell
                    write(*,*) "m_SEIndex_ForCell(IDCell,1),m_SEIndex_ForCell(IDCell,2)",m_SEIndex_ForCell(IDCell,1),m_SEIndex_ForCell(IDCell,2)

                    DO JC = m_SEIndex_ForCell(IDCell,1),m_SEIndex_ForCell(IDCell,2)
                        write(*,*) "SortedIndex_ForCell_Host",SortedIndex_ForCell_Host(JC)
                    END DO


                    DO JC = 1,NSize
                        if(SortedIndex_ForCell_Host(JC) .eq. IC) then
                            write(*,*) "SortedCellIndex_Host(JC)",SortedCellIndex_Host(JC)
                        end if

                    END DO

                    DO JC = 1,NSize
                        if(SortedCellIndex_Host(JC) .eq. IDCell) then
                            write(*,*) "SortedCellIndex_Host(JC)",SortedCellIndex_Host(JC),"SortedIndex_ForCell_Host",SortedIndex_ForCell_Host(JC)
                        end if

                    END DO

                end if

            END DO

            pause
            stop
        end if

    END DO


    return
  end subroutine


  attributes(global) subroutine Kernel_CheckLC(BlockNumEachBox,              &
                                               Dev_Clusters,                 &
                                               Dev_SEExpdIndexBox_ForBox,    &
                                               Dev_SEExpdIndexBox_ForCell,   &
                                               SortedIndex_ForCell_Dev,      &
                                               CellsNumOneDim,               &
                                               Finded)
    implicit none
    !--Dummy Vars---
    integer,value::BlockNumEachBox
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox_ForBox(:,:)
    integer, device::Dev_SEExpdIndexBox_ForCell(:,:)
    integer,device::SortedIndex_ForCell_Dev(:)
    integer,device::Finded(:)
    integer,value::CellsNumOneDim
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::bid0
    integer::IC
    integer::JC
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::maxDistance
    real(kind=KINDDF)::minDistance
    real(kind=KINDDF)::LastMinDistance
    integer::NNID
    integer::scid,ecid
    integer::IXCell,IYCell,IZCell
    logical::breakCondition
    integer::IDCell
    integer::JCFrom,JCTo
    integer::ICellStart
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

    scid = Dev_SEExpdIndexBox_ForBox(IBox,1)
	ecid = Dev_SEExpdIndexBox_ForBox(IBox,2)

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

	ICellStart = (IBox-1)*(CellsNumOneDim**3) + 1

	if (IC .LE. ecid) then

        Pos_X = Dev_Clusters(IC)%m_POS(1)
        Pos_Y = Dev_Clusters(IC)%m_POS(2)
        Pos_Z = Dev_Clusters(IC)%m_POS(3)

        RADA = Dev_Clusters(IC)%m_RAD

        DiffA = Dev_Clusters(IC)%m_DiffCoeff

        IXCell = int((Pos_X - dm_BOXBOUNDARY(1,1))/(dm_BOXSIZE(1)/CellsNumOneDim))
        IXCell = min(IXCell,CellsNumOneDim-1)
        IXCell = max(IXCell,0)
        IYCell = int((Pos_Y - dm_BOXBOUNDARY(2,1))/(dm_BOXSIZE(2)/CellsNumOneDim))
        IYCell = min(IYCell,CellsNumOneDim-1)
        IYCell = max(IYCell,0)
        IZCell = int((Pos_Z - dm_BOXBOUNDARY(3,1))/(dm_BOXSIZE(3)/CellsNumOneDim))
        IZCell = min(IZCell,CellsNumOneDim-1)
        IZCell = max(IZCell,0)
        IDCell = ICellStart + IZCell*CellsNumOneDim*CellsNumOneDim + IYCell*CellsNumOneDim + IXCell

        Finded(IC) = -1*IDCell

        JCFrom = Dev_SEExpdIndexBox_ForCell(IDCell,1)
        JCTo = Dev_SEExpdIndexBox_ForCell(IDCell,2)

        DO JC = JCFrom,JCTo
            MappedJC = SortedIndex_ForCell_Dev(JC)
            if(MappedJC .eq. IC) then
                Finded(IC) = 1
            end if
        END DO

	 end if

    return

  end subroutine Kernel_CheckLC


  !************************************************************************************
  attributes(global) subroutine Kernel_Neighbore_Table_GPU_Nearest_LC(BlockNumEachBox,              &
                                                                      Dev_Clusters,                 &
                                                                      Dev_SEExpdIndexBox_ForBox,    &
                                                                      KVOIS,                        &
                                                                      INDI,                         &
                                                                      Dev_SEExpdIndexBox_ForCell,   &
                                                                      SortedIndex_ForCell_Dev,      &
                                                                      CellsNumOneDim,               &
                                                                      MinTSteps,                    &
                                                                      maxDiffuse)
    implicit none
    !--Dummy Vars---
    integer,value::BlockNumEachBox
    type(ACluster), device::Dev_Clusters(:)
    integer, device::Dev_SEExpdIndexBox_ForBox(:,:)
    integer,device::KVOIS(:)
    integer,device::INDI(:,:)
    integer, device::Dev_SEExpdIndexBox_ForCell(:,:)
    integer,device::SortedIndex_ForCell_Dev(:)
    integer,value::CellsNumOneDim
    real(kind=KINDDF),device::MinTSteps(:)
    real(kind=KINDDF),value::maxDiffuse
    !---Local Vars---
    integer::IBox
    integer::tid
    integer::bid
    integer::cid
    integer::bid0
    integer::IC
    integer::JC
    integer::MappedJC
    integer::STATUIC,STATUJC
    integer::Shift
    real(kind=KINDSF)::Pos_X,Pos_Y,Pos_Z,Sep_x,Sep_y,Sep_z
    real(kind=KINDSF)::DiffA,DiffB,RADA,RADB
    real(kind=KINDSF)::DIST2
    real(kind=KINDDF)::MinT,reactTime
    real(kind=KINDDF)::maxDistance
    real(kind=KINDDF)::minDistance
    real(kind=KINDDF)::LastMinDistance
    integer::NNID
    integer::scid,ecid
    integer::IXCell,IYCell,IZCell
    integer::JXCell,JYCell,JZCell
    integer::TrueJXCell,TrueJYCell,TrueJZCell
    integer::IDCell
    integer::JDCell
    integer::JCFrom,JCTo
    integer::ICellStart
    integer::increasement
    real(kind=KINDDF)::xDist,yDist,zDist
    !---Body---
    tid = (threadidx%y-1)*blockdim%x + threadidx%x       ! the thread index inner this block
    bid = (blockidx%y-1)*griddim%x +  blockidx%x         ! the index of block
    cid = (bid-1)*p_BLOCKSIZE_MyMethod + tid                      ! the first thread index of this block

	IBox = (bid-1)/BlockNumEachBox + 1

	bid0 = (IBox-1)*BlockNumEachBox + 1

    scid = Dev_SEExpdIndexBox_ForBox(IBox,1)
	ecid = Dev_SEExpdIndexBox_ForBox(IBox,2)

	IC = scid + (cid - (bid0 -1)*p_BLOCKSIZE_MyMethod - 1)

	ICellStart = (IBox-1)*(CellsNumOneDim**3) + 1

	MinT = 1.D32
	LastMinDistance = 1.D32
    minDistance = 1.D32
    maxDistance = -1
	if (IC .LE. ecid) then

        STATUIC = Dev_Clusters(IC)%m_Statu

        IF(STATUIC .EQ. p_ACTIVEFREE_STATU .or. STATUIC .EQ. p_ACTIVEINGB_STATU) THEN
          Pos_X = Dev_Clusters(IC)%m_POS(1)
          Pos_Y = Dev_Clusters(IC)%m_POS(2)
          Pos_Z = Dev_Clusters(IC)%m_POS(3)

          RADA = Dev_Clusters(IC)%m_RAD

          DiffA = Dev_Clusters(IC)%m_DiffCoeff

          IXCell = int((Pos_X - dm_BOXBOUNDARY(1,1))/(dm_BOXSIZE(1)/CellsNumOneDim))
          IXCell = min(IXCell,CellsNumOneDim-1)
          IXCell = max(IXCell,0)
          IYCell = int((Pos_Y - dm_BOXBOUNDARY(2,1))/(dm_BOXSIZE(2)/CellsNumOneDim))
          IYCell = min(IYCell,CellsNumOneDim-1)
          IYCell = max(IYCell,0)
          IZCell = int((Pos_Z - dm_BOXBOUNDARY(3,1))/(dm_BOXSIZE(3)/CellsNumOneDim))
          IZCell = min(IZCell,CellsNumOneDim-1)
          IZCell = max(IZCell,0)
          IDCell = ICellStart + IZCell*CellsNumOneDim*CellsNumOneDim + IYCell*CellsNumOneDim + IXCell


          DO Shift = 0,(CellsNumOneDim-1)/2 + 1
            increasement = max(2*Shift,1)

            !****A*****
            DO JXCell = IXCell - Shift,IXCell + Shift,increasement

                TrueJXCell = JXCell
                if(JXCell .LT. 0 .AND. dm_PERIOD(1) .GT. 0) then
                    TrueJXCell = JXCell + CellsNumOneDim
                end if

                if(JXCell .GE. CellsNumOneDim .AND. dm_PERIOD(1) .GT. 0) then
                    TrueJXCell = JXCell - CellsNumOneDim
                end if

                DO JYCell = IYCell - Shift,IYCell + Shift,1

                    TrueJYCell = JYCell
                    if(JYCell .LT. 0 .AND. dm_PERIOD(2) .GT. 0) then
                        TrueJYCell = JYCell + CellsNumOneDim
                    end if

                    if(JYCell .GE. CellsNumOneDim .AND. dm_PERIOD(2) .GT. 0) then
                        TrueJYCell = JYCell - CellsNumOneDim
                    end if

                    DO JZCell = IZCell - Shift,IZCell + Shift,1

                        TrueJZCell = JZCell
                        if(JZCell .LT. 0 .AND. dm_PERIOD(3) .GT. 0) then
                            TrueJZCell = JZCell + CellsNumOneDim
                        end if

                        if(JZCell .GE. CellsNumOneDim .AND. dm_PERIOD(3) .GT. 0) then
                            TrueJZCell = JZCell - CellsNumOneDim
                        end if

                        JDCell = ICellStart + TrueJZCell*CellsNumOneDim*CellsNumOneDim + TrueJYCell*CellsNumOneDim + TrueJXCell

                        JCFrom = Dev_SEExpdIndexBox_ForCell(JDCell,1)
                        JCTo = Dev_SEExpdIndexBox_ForCell(JDCell,2)

                        DO JC = JCFrom,JCTo
                            MappedJC = SortedIndex_ForCell_Dev(JC)

                            if(MappedJC .ne. IC) then
                                STATUJC = Dev_Clusters(MappedJC)%m_Statu

                                if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                                    SEP_x = SEP_x*SEP_x

                                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                                    SEP_y = SEP_y*SEP_y

                                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                                    SEP_z = SEP_z*SEP_z

                                    DIST2 = SEP_x + SEP_y + SEP_z

                                    if(DIST2 .GT. maxDistance) then
                                        maxDistance = DIST2
                                    end if

                                    RADB = Dev_Clusters(MappedJC)%m_RAD

                                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                                    if(reactTime .LE. MinT ) then
                                        MinT = reactTime
                                        NNID = MappedJC
                                        LastMinDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                                        !minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                                    end if

                                end if

                            end if

                        END DO

                    END DO
                END DO
            END DO

            !****B*****
            DO JYCell = IYCell - Shift,IYCell + Shift,increasement

                TrueJYCell = JYCell
                if(JYCell .LT. 0 .AND. dm_PERIOD(2) .GT. 0) then
                    TrueJYCell = JYCell + CellsNumOneDim
                end if

                if(JYCell .GE. CellsNumOneDim .AND. dm_PERIOD(2) .GT. 0) then
                    TrueJYCell = JYCell - CellsNumOneDim
                end if

                DO JXCell = IXCell - Shift + 1,IXCell + Shift-1,1

                    TrueJXCell = JXCell
                    if(JXCell .LT. 0 .AND. dm_PERIOD(1) .GT. 0) then
                        TrueJXCell = JXCell + CellsNumOneDim
                    end if

                    if(JXCell .GE. CellsNumOneDim .AND. dm_PERIOD(1) .GT. 0) then
                        TrueJXCell = JXCell - CellsNumOneDim
                    end if

                    DO JZCell = IZCell - Shift,IZCell + Shift,1

                        TrueJZCell = JZCell
                        if(JZCell .LT. 0 .AND. dm_PERIOD(3) .GT. 0) then
                            TrueJZCell = JZCell + CellsNumOneDim
                        end if

                        if(JZCell .GE. CellsNumOneDim .AND. dm_PERIOD(3) .GT. 0) then
                            TrueJZCell = JZCell - CellsNumOneDim
                        end if


                        JDCell = ICellStart + TrueJZCell*CellsNumOneDim*CellsNumOneDim + TrueJYCell*CellsNumOneDim + TrueJXCell

                        JCFrom = Dev_SEExpdIndexBox_ForCell(JDCell,1)
                        JCTo = Dev_SEExpdIndexBox_ForCell(JDCell,2)

                        DO JC = JCFrom,JCTo
                            MappedJC = SortedIndex_ForCell_Dev(JC)

                            if(MappedJC .ne. IC) then
                                STATUJC = Dev_Clusters(MappedJC)%m_Statu

                                if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                                    SEP_x = SEP_x*SEP_x

                                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                                    SEP_y = SEP_y*SEP_y

                                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                                    SEP_z = SEP_z*SEP_z

                                    DIST2 = SEP_x + SEP_y + SEP_z

                                    if(DIST2 .GT. maxDistance) then
                                        maxDistance = DIST2
                                    end if

                                    RADB = Dev_Clusters(MappedJC)%m_RAD

                                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                                    if(reactTime .LE. MinT ) then
                                        MinT = reactTime
                                        NNID = MappedJC
                                        LastMinDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                                        !minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                                    end if

                                end if

                            end if

                        END DO


                    END DO
                END DO
            END DO

            !****C*****
            DO JZCell = IZCell - Shift,IZCell + Shift,increasement

                TrueJZCell = JZCell
                if(JZCell .LT. 0 .AND. dm_PERIOD(3) .GT. 0) then
                    TrueJZCell = JZCell + CellsNumOneDim
                end if

                if(JZCell .GE. CellsNumOneDim .AND. dm_PERIOD(3) .GT. 0) then
                    TrueJZCell = JZCell - CellsNumOneDim
                end if

                DO JXCell = IXCell - Shift + 1,IXCell + Shift-1,1

                    TrueJXCell = JXCell
                    if(JXCell .LT. 0 .AND. dm_PERIOD(1) .GT. 0) then
                        TrueJXCell = JXCell + CellsNumOneDim
                    end if

                    if(JXCell .GE. CellsNumOneDim .AND. dm_PERIOD(1) .GT. 0) then
                        TrueJXCell = JXCell - CellsNumOneDim
                    end if

                    DO JYCell = IYCell - Shift + 1,IYCell + Shift -1,1

                        TrueJYCell = JYCell
                        if(JYCell .LT. 0 .AND. dm_PERIOD(2) .GT. 0) then
                            TrueJYCell = JYCell + CellsNumOneDim
                        end if

                        if(JYCell .GE. CellsNumOneDim .AND. dm_PERIOD(2) .GT. 0) then
                            TrueJYCell = JYCell - CellsNumOneDim
                        end if

                        JDCell = ICellStart + TrueJZCell*CellsNumOneDim*CellsNumOneDim + TrueJYCell*CellsNumOneDim + TrueJXCell

                        JCFrom = Dev_SEExpdIndexBox_ForCell(JDCell,1)
                        JCTo = Dev_SEExpdIndexBox_ForCell(JDCell,2)

                        DO JC = JCFrom,JCTo
                            MappedJC = SortedIndex_ForCell_Dev(JC)

                            if(MappedJC .ne. IC) then
                                STATUJC = Dev_Clusters(MappedJC)%m_Statu

                                if(STATUJC .eq. p_ACTIVEFREE_STATU .or. STATUJC .eq. p_ACTIVEINGB_STATU) then

                                    SEP_x = Pos_X - Dev_Clusters(MappedJC)%m_POS(1)
                                    SEP_x = SEP_x - (int(ABS(SEP_x)/dm_HBOXSIZE(1))*dm_PERIOD(1))*SIGN(dm_BOXSIZE(1),SEP_x)
                                    SEP_x = SEP_x*SEP_x

                                    SEP_y = Pos_y - Dev_Clusters(MappedJC)%m_POS(2)
                                    SEP_y = SEP_y - (int(ABS(SEP_y)/dm_HBOXSIZE(2))*dm_PERIOD(2))*SIGN(dm_BOXSIZE(2),SEP_y)
                                    SEP_y = SEP_y*SEP_y

                                    SEP_z = Pos_z - Dev_Clusters(MappedJC)%m_POS(3)
                                    SEP_z = SEP_z - (int(ABS(SEP_z)/dm_HBOXSIZE(3))*dm_PERIOD(3))*SIGN(dm_BOXSIZE(3),SEP_z)
                                    SEP_z = SEP_z*SEP_z

                                    DIST2 = SEP_x + SEP_y + SEP_z

                                    if(DIST2 .GT. maxDistance) then
                                        maxDistance = DIST2
                                    end if

                                    RADB = Dev_Clusters(MappedJC)%m_RAD

                                    DiffB = Dev_Clusters(MappedJC)%m_DiffCoeff

                                    DIST2 = max(SQRT(DIST2) - RADA - RADB,0.E0)

                                    reactTime = (DIST2*DIST2)*(1.D0/6.D0)/(DiffA + DiffB + 2*SQRT(DiffA*DiffB))  ! time

                                    if(reactTime .LE. MinT) then
                                        MinT = reactTime
                                        NNID = MappedJC
                                        LastMinDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = SQRT(6.D0*DiffA*MinT) + SQRT(6.D0*maxDiffuse*MinT) + RADA + RADB
                                        !minDistance = 24.D0*maxDiffuse*MinT   !(2*SQRT(6.D0*maxDiffuse*MinT))**2
                                        !minDistance = 2*SQRT(6.D0*DiffA*MinT) + RADA + RADB
                                    end if

                                end if

                            end if

                        END DO
                    END DO
                END DO
            END DO

            !****Break condition************

            LastMinDistance = LastMinDistance*LastMinDistance
!            if(LastMinDistance .LT. maxDistance .AND. Shift .GT. 1 .AND. maxDistance .GT. 0) then
!                exit
!            end if


            LastMinDistance = LastMinDistance*LastMinDistance
            if(Shift .GT. 1 .AND. maxDistance .GT. 0) then
                DO JZCell = IZCell - Shift,IZCell + Shift,increasement

                    if(JZCell .GT. IZCell) then
                        zDist = (JZCell + 1)*dm_BOXSIZE(3)/CellsNumOneDim - Pos_Z
                    end if

                    if(JZCell .LT. IZCell) then
                        zDist = Pos_Z - JZCell*dm_BOXSIZE(3)/CellsNumOneDim
                    end if

                    DO JYCell = IYCell - Shift,IYCell + Shift,increasement

                        if(JYCell .GT. IYCell) then
                            yDist = (JYCell + 1)*dm_BOXSIZE(2)/CellsNumOneDim - Pos_Y
                        end if

                        if(JYCell .LT. IYCell) then
                            yDist = Pos_Y - JYCell*dm_BOXSIZE(2)/CellsNumOneDim
                        end if

                        DO JXCell = IXCell - Shift,IXCell + Shift,increasement
                            if(JXCell .GT. IXCell) then
                                xDist = (JXCell + 1)*dm_BOXSIZE(1)/CellsNumOneDim - Pos_X
                            end if

                            if(JXCell .LT. IXCell) then
                                xDist = Pos_X - JXCell*dm_BOXSIZE(1)/CellsNumOneDim
                            end if

                            if(LastMinDistance .LT. (xDist*xDist + yDist*yDist + zDist*zDist)) then
                                exit
                            end if

                        END DO

                    END DO

                END DO
            end if



          END DO

          KVOIS(IC) = 1
		  INDI(IC,1) = NNID
		  MinTSteps(IC) = MinT
        end if
	 end if

	 return

    return
  end subroutine Kernel_Neighbore_Table_GPU_Nearest_LC

end module MCLIB_CAL_NEIGHBOR_LIST_GPU
